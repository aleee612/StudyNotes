- 可以对同一个包内的其他类进行隐藏
- 内部类方法可以访问定义外部类的作用域中的数据，包括原本私有的数据
- Java中内部类的对象会有一个隐式引用指向实例化这个对象的外部类对象；这也就是为什么一个内部类可以用外围类对象的数据字段
- 在Java中的静态内部类没有这个指针，因此可以认为Java的静态类相当于cpp的嵌套类
```java
public class Outer
{
	private boolean flag;
	public Outer(boolean f)
	{
		this.flag = f;
	}
	public class Inner
	{
		...
		if(flag) { ... }//可以访问
		if(Outer.this.flag) { ... }//正规语法
		...
	}
}
```
### 引用内部类
```java
Outer.Inner

//声明内部类对象
var Out = new Outer(true);
Outer.Inner In = Out.new Inner();
```
### 注意事项
- 内部类中的所有声明的静态字段都为[[类与对象#final实例字段|final]]，并初始化一个编译时常量
- 内部类中的static方法不能直接访问外部类的非静态字段（类方法本就不可访问实例方法和字段）
### 局部内部类
- 在方法中定义的类
```java
public void start(){
	class Inner{
		public void fun(){
			...
		}
	}
}
```
- 局部类不能有[[访问说明符]]
- 局部类的作用域仅限该代码块中
- 除start方法外，没有任何方法知道Inner存在
- 同[[语法/Java/类&接口/语法糖缩写/lambda表达式|lambda表达式]]，局部类也可以访问方法内的局部变量，同时要求该变量为事实最终变量
### 匿名内部类
- 只创建这个类的一个对象，而不需要为其指定名字
```java
class Father { ... }
interface Interface { ... }
...
public void fun(){
	var in = new InterFace() {
		public void fun(){
			System.out.println();
		}
	};
	var inn = new Father() { ... };
}
```
- 注意在匿名内部类的结尾需要使用`;`
- 可以分为实现接口的匿名内部类和不实现接口的（这时候就是继承父类），内部类无法单独存在
- 内部类不能有构造器，因为匿名类没有名字而构造器和类名同名
### 静态内部类
- 将不会产生对外部类的引用
- 仅存在静态内部类，而不存在静态顶级类
- 适合做不被外界直接访问的工具