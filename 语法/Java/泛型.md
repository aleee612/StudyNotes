### 泛型类
```java
public class ClassName<T, U>
{
	public T name;
	public T fun(T a) { this.name = a; }
}
```
- 用尖括号括起来类型变量
- 类型变量的意义：
	- T、U、S：任意类型
	- E：集合的元素类型
	- K、V：键、值
### 泛型方法
- `<T>`方法写在函数返回类型前，可以使用extends限定泛型的适用范围（如下例则为实现Comparable和Serializable接口）
- `&`用于分隔限定类型，而`,`用于分隔类型变量
```java
class ClassName{
	public <T,U extends Comparable & Serializable> T fun(T a){
		return a;
	}
}
```
- 使用方法:
```java
String name = ClassName.fun("good");
String name = ClassName.<String>fun("good");
```
### 类型擦除
- 类型擦除就是编译器在编译时保留类型检查，但在生成的字节码里，把所有泛型类型替换成它们的上限（通常是 Object）
- 使用Object代替T
- 若此时有限定泛型的适用范围，则使用第一个限定来替代T
- 当调用该泛型类/方法时，将发生强制类型转换
### 限制与局限性
1. 不能用**基本类型**实例化类型参数，而需要使用包装后的类型，原因在于类型擦除
2. 运行时的类型查询只适用于原始类型，而getClass只会返回原始类型（即擦除后的类型）
3. 不能创建参数化类型的数组
```java
var table = new Pair<String>[10]; //×
```
4. 但是对于可变长传参却只会有一个警告（因为太好用所以有特权？）
5. 不能在new T( ... )的表达式中使用类型变量
```java
public Pair()//构造方法中
{
	first = new T();//Error
	second = new T();
}
```
6. 问题5解决方法：在声明时使用：
```java
Pair<String> p = Pair.makePair(String::new);
```
而在类中：
```java
public static <T> Pair<T> makePair(Supplier<T> constr)
{
	return new Pair<>(constr.get(),constr.get());
}
```
Supplier内部：
```java
@FunctionalInterface
public interface Supplier<T> {
    T get();  // 唯一方法
}
```
