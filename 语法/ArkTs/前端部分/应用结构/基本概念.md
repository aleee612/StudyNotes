# ArkTS 应用结构思维导图

```
@Entry
│
└───> @Component
       │
       └───> struct MyApp {
                build() {
                  // UI 构建逻辑
                  Text("Hello, ArkTS!")
                }
              }
```

---

### `@Entry`

- 表示 **入口组件**；
- App 启动时，系统会从这个组件开始构建 UI；
- 只能标记在一个组件上。

---

### `@Component`

- 表示这是一个 **可视 UI 组件**（ 这样才会渲染 ）；
- 必须配合结构体 `struct xxx` 使用；
- 内部必须定义 `build()` 方法来构建 UI 内容；
- 如果 **不加** `**@Component**`，这个结构体就**不会被识别为 UI 组件**，也就不会被框架拿去执行 `build()`，更不会渲染到屏幕上 。

---

### `build()`

- 是组件的 UI 构造函数；
- 你所有的页面结构（Text、Button、Column、Row 等）都要写在这里；
- 会被系统自动调用来展示页面；

- 每当组件状态变了，系统会自动重新调用 `build()`，把界面更新；

- 如果没有 `build()`，编译器直接报错，因为它找不到「这个组件要显示什么」。

---

`@Entry` 是**起点**，`@Component` 是**组件声明**，`build()` 是**画页面的地方**

# 为什么在组件结构体 `struct` 内不能随便写 `function` 或 `let`

**因为组件是用来描述 UI 的，不是用来承载普通逻辑代码的！**

ArkTS 的组件结构 `@Component struct` 不是传统意义的类或结构体，它是“声明式 UI **语法糖**”的一种形式，结构上必须遵循 ArkUI 的编译要求。

## ArkTS 是怎么划分职责的？

|   |   |   |
|---|---|---|
|区域|可以干啥？|举例|
|组件 `struct` 体中|只能写 UI 属性（`@State`, `@Prop`, `build()` 等）|✅|
|`build()` 方法中|写 UI 结构和行为（Text、Button、事件绑定）|✅|
|struct 外|写函数、变量、工具逻辑|✅ 推荐|

---

## 正确方法：逻辑函数写外面

```
function sayHello(name: string): string {
  return "你好，" + name
}

@Component
struct MyCard {
  @Prop name: string

  build() {
    Text(sayHello(this.name))  // ✅ 正确使用
  }
}
```

- 可以把函数写在组件 **外部**，然后在 `build()` 内调用，这样就既符合 ArkTS 的规则，又能保持代码清晰！

---

## 那状态变量怎么办

- 如果想让变量在组件中用、还能触发更新，那就在`struct`中`build`外用：

|   |   |   |
|---|---|---|
|修饰符|作用|用法|
|`@State`|本地状态，组件内读写|`@State count: number = 0;`|
|`@Prop`|父组件传值，只读|`@Prop title: string;`|
|`@Link`|父子双向绑定|`@Link count: number;`|

---