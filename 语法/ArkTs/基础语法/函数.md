## 有名函数

- 基本语法格式：`function 函数名(参数名:类型):返回值类型{ 函数体 }`

- 返回值类型可不写（有类型判断）

```
function add(x:number,y:number):number{
  return x+y;
}
```

## 匿名函数（在ArkTS中会报错）

- 基本语法格式：`let 变量名 = function(参数名:类型):返回值类型{ 函数体 }`

```
let add = function(x:number,y:number):number{
  return x+y;
}
```

---

## 可选参数

- 可选参数一定要在所有参数的最后位

- 基本可选的格式都为 `参数名?:类型`

```
function add(x:number,y?:number){
  return x+y;
}
```

**可选参数的类型是 `T | undefined`，**即可能是 **指定类型** 或 `undefined`。

- 如果不传参，默认值是 `undefined`

- 可选参数可以有默认值，这样即使不传，也会有一个默认的有效值，**默认值生效时，可选参数不会是** `undefined`，而是默认值本身。

---

## 剩余参数

- 剩余参数同样的一定要在所有参数的最后位

- 基本可选的格式都为 `…参数名:类型`

- 剩余参数的类型必须是**数组,**比如 `string[]` 或 `number[]`。

### **✅** **正确示例**

```
function sum(...nums: number[]) {
  return nums.reduce((total, num) => total + num, 0);
}
console.log(sum(1,  3, 4));  // 输出 10
```

### **❌** **错误示例**

```
function incorrect(...values: number) {  // ❌ 错误：剩余参数必须是数组
  console.log(values);
}
```

**错误输出：**

```
A rest parameter must be of an array type.
```

- 剩余参数可以是**可选**参数，但不能有**默认值**

- 剩余参数可以和 **元组** 结合使用，使得参数有固定的结构。

### **✅** **正确示例**

```
function showDetails(...details: [string, number]) {
  console.log(`Name: ${details[0]}, Age: ${details[1]}`);
}

showDetails("Alice", 25);  // 输出: Name: Alice, Age: 25
```

但要注意，**剩余参数不能同时混合多种类型，除非定义为元组**。

### **❌** **错误示例**

```
function incorrect(...values: string | number[]) {  // ❌ 错误：剩余参数必须是数组
  console.log(values);
}
```

---

## 函数重载

- 函数重载的参数不相同

```
function foo(value: number): string;
function foo(value: string): number;
function foo(value: number | string): string | number {
  if (typeof value === "number") {
    return value.toString();
  } else {
    return value.length;
  }
}
//注意：只有实现体（最后一个 foo）包含具体的代码，前面的重载签名只是类型提示。
```

- TypeScript 允许可选参数 (`?`)，但在 ArkTS 中，使用可选参数可能导致某些重载不生效：

```
function test(a: string, b?: number): void;
function test(a: number, b: string): void; // ⚠️ 可能冲突
function test(a: string | number, b?: number | string): void {
  console.log(a, b);
}
```

**推荐做法**：

- 使用 **联合类型**

- 避免 **可选参数 + 重载**

- TypeScript（包括 ArkTS）会从 **上到下匹配** 重载声明，优先匹配最具体的类型：

```
function greet(person: "Alice"): string;
function greet(person: string): string;
function greet(person: string): string {
  if (person === "Alice") {
    return "Hello Alice!";
  }
  return "Hello " + person;
}

console.log(greet("Alice")); // 调用第一个重载
console.log(greet("Bob"));   // 调用第二个重载
```

**注意**：如果顺序反了，`"Alice"` 可能匹配到 `stri` 而非 `"Alice"`。