# 声明

```
class 类名 {
  成员属性
  构造函数
  成员方法
};
```

### 类名

- 要求首字母大写

```
class Person { ... };
```

### 成员属性

- 可用 `private`、`public`、`protected` 修饰

- 不用 `let` 声明变量

- 成员属性**必须有初始值**

初始化方式有以下几种：

```
// 方法一：直接初始化
age: number = 18;

// 方法二：可选成员 + 初始化
age?: number = 18;

// 方法三：构造函数中初始化
age: number;
constructor(age: number) {
  this.age = age;
}
```

### 构造函数

- 使用 `constructor()` 定义

- 在 `new` 类的时候自动调用

```
constructor(name: string) {
  this.name = name;
}
```

### 成员方法

- 不用 `function` 关键字，直接定义方法名

```
sayHello(): void {
  console.log("Hello!");
}
```

# 修饰符（访问权限）

|   |   |
|---|---|
|修饰符|说明|
|`public`|公有，类内外都可以访问（默认）|
|`private`|私有，只能在类内部访问|
|`protected`|受保护，只能在类内部和子类中访问|

# 调用

### 创建对象：new关键字

```
let jack = new Person("Jack");
```

### 类中访问属性或方法

```
this.age;
this.sayHello();
```

### static（静态成员）

- 使用 `static` 修饰

- 属于类本身，**不属于实例，也就是通过类来调用**

- 访问方式：

```
class Person {
  static species: string = "Human";
  change(){
    Person.species = " ";
  }
}

Person.species; // 访问静态属性
```

## 链式调用

- 链式调用时要将需调用的函数返回值设置为类本身（即`:类名`+`return this`）
- 链式调用调用成员属性的时候要把他放在最后一位，因为他没有返回值

```
class JDZText
{
  name: string = "aaa";

  constructor() {
  }

  hello():JDZText
  {
    console.log(this.name);
    return this;
  }
  change():JDZText
  {
    this.name = "a";
    return this;
  }
}
let alee:JDZText = new JDZText;
alee
  .hello()
  .change()
```

---

# 抽象类

- 使用 `abstract` 关键字定义

- 不能被实例化（**不能用** `new` **创建对象**）

- 通常作为“模板”被子类继承

- 可以包含：

- 抽象方法（没有方法体，子类**必须实现**）

- 普通方法和属性（子类可以继承/使用）

### 抽象类定义

```
abstract class Animal {
  abstract makeSound(): void; // 抽象方法（必须被实现）

  move(): void {
    console.log("Moving...");
  }
}
```

### 子类继承并实现抽象方法

```
class Dog extends Animal {
  makeSound(): void {
    console.log("Woof!");
  }
}
```

### 错误示例：不能直接创建抽象类对象

```
let a = new Animal(); // ❌ 错误：抽象类不能被实例化
```

### 正确示例：使用子类创建对象

```
let dog = new Dog();
dog.makeSound(); // 输出：Woof!
dog.move();      // 输出：Moving...
```