---
aliases:
  - rdt
---
### 如何实现可靠数据传输？（理论）
- 推荐使用单一的[[重传定时器]]
**当发送端只用超时来恢复报文段的丢失：**
1. 通过RTT计算是否超时
2. 若超时则重传并重置定时器
3. 判断ACK与SendBase，通过累积确认确定字节编号y（ACK 的值）在y之前的所有字节都已经收到
4. 若y>SendBase，则表示ACK在确认一个或多个先前未被确认的报文段，发送方将更新其SendBase变量并重启定时器
- 每一个重传超时间隔都是前一个的两倍（对于同一段数据）
**当再加上冗余确认技术**
1. 发送方通过注意冗余ACK来检测丢包情况
2. 产生冗余ACK的原因：![[Pasted image 20251014090316.png]]
3. TCP发送方一但接收到三个冗余ACK则执行快速重传
**选择确认**：[[流水线可靠数据传输协议（P-RDT）#回退N步GBN（滑动窗口协议）|GBN]]和[[流水线可靠数据传输协议（P-RDT）#选择重传SR|SR]]的混合体
- 允许TCP接收方有选择地确认失序报文段，而非累积地确认最后一个正确接收的有序报文段
- TCP最多重传一个报文段，因此不是传统意义上的GBN
- TCP使用累积确认，由此可见也并非传统SR
- 实现在运输层
- 可靠数据传输协议的下一层可能是不可靠的，可将较低层直接视为不可靠的点对点信道
### 具体实施（实践）
#### rdt 1.0
- 最简单的情况：底层信道完全可靠
- 这个阶段其实rdt啥都没做，只是假设它为可靠而已
- 发送方/接收方都有一个[[有限状态机FSM]]用于定义自身状态
- 引起变迁的事件：
	- 发送方：`rdt_send(data)` -> 上层调用数据传输协议
	- 接收方：`rdt_rcv(packet)` -> 分组从信道到达
- FSM采取的行动：
	- 发送方：
		1. `packet = make_pkt(data)` -> 产生包含数据的分组
		2. `udt_send(packet)` -> （udt：_unreliable data transfer_（**不可靠的数据传输**））把数据包通过不可靠的信道发出去
	- 接收方：
		1. `extract(packet,data)` -> 从（不可靠信道）收到的分组中提取出数据部分
		2. `deliver_data()` -> 向较高层（应用层）交付数据
	- ⋀：表示缺少 动作/事件
- 有了完全可靠的信道，接收端不需要提供任何反馈信息给发送方
- 由于假定接受方的接收速率能和发送方一样快，所以没必要请求发送方慢点
#### rdt 2.0
- 假定所有发送的分组将按其发送的顺序被接收（虽然有些比特可能会受损）
- [[自动重传请求协议（ARQ）]]：使用 肯定（ACK）/否定（NAK） 确认，让接收方知道有 哪些内容被正确接收/哪些有误需重传
- 引起变迁的事件：
	- 发送方：
		1. `rdt_send(data)` -> 上层调用数据传输协议
		2. `rdt_rcv(rcvpkt) && isNAK(rcvpkt)` /  `rdt_rcv(rcvpkt) && isACK(rcvpkt)` -> 接收反馈信息，判断是否为NAK/ACK
	- 接收方：
		1.  `rdt_rcv(rcvpkt)` -> 分组从信道到达
		2. `corrupt(rcvpkt)`/ `notcorrupt(rcvpkt)`-> corrupt检查这个收到的包是否在传输过程中被损坏
- FSM采取的行动：
	- 发送方：
		1. `sndpkt = make_pkt(data,checksum)` -> 产生包含数据+校验和的分组
		2. `udt_send(packet)` -> 把数据包通过不可靠的信道发出去
		3. 当变迁事件为接收到NAK时，重新`udt_send(packet)`
		4. 当变迁事件为接收到ACK时，不做操作
	- 接收方：
		1. 当变迁事件为corrupt，则`sndpkt = make_pkt(NAK) && udt_send(packet)` -> 传输回NAK表示数据已损坏
		2. 当变迁事件为notcorrupt时，`extract(packet,data)` -> 从（不可靠信道）收到的分组中提取出数据部分
		3. 在 2 的基础上，用`deliver_data()` -> 向较高层（应用层）交付数据
		4. `sndpkt = make_pkt(ACK) && udt_send(packet)` -> 传输回ACK表示数据完整
- 注意事项：当发送方处于等待ACK/NAK状态时不能从上层获得更多数据，因此2.0也被称为**停等协议**
- 处理受损ACK/NAK：在数据分组中添加一新字段，让发送方对其数据分组编号，若接收数据正确则传输编号ACK（一般为0或1的1bit数据），若未接收到则不发NAK；当ACK为损坏时发送方将重发数据。这在2.1，2.2中实现
#### rdt 3.0
- 主要解决丢包问题
- 3.0也是一个停等协议
- 比特交替协议：分组序号在0和1之间交替
- 新定义了一个倒计数定时器，用于判断是否丢包，当超时未接收到ACK时，将重新发送分组
![[Pasted image 20251010164753.png]]