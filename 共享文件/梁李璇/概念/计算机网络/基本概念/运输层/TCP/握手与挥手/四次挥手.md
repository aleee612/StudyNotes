### 关闭连接
![[Pasted image 20251014095344.png]]
1. 客户发送关闭连接：
	FIN = 1，seq=u；
	发送后，客户端进入 **FIN-WAIT-1** 状态
2. 服务器端发送确认ACK：
	ack=u+1；
	发送后，服务端进入 **CLOSE-WAIT** 状态
	客户端收到这个 ACK 后，进入 **FIN-WAIT-2** 状态
	此时，TCP 连接处于**半关闭（Half-Close）** 状态：客户端到服务端的发送通道已关闭，但服务端到客户端的发送通道仍然可以传输数据。
3. 服务器端发送自己的终止报文段：
	FIN = 1，seq=y；
	发送后，服务端进入 **LAST-ACK** 状态
4. 客户端确认发送ACK：
	ack=y+1；
	发送后，客户端进入 **TIME-WAIT** 状态
	服务端：收到这个 ACK 后，立即进入 **CLOSED** 状态，完成连接关闭
	客户端：在 **TIME-WAIT** 状态下等待 **2MSL**后，才最终进入 **CLOSED** 状态
-  缘由：TCP是全双工，则关闭也得是双向的。否则一方关闭连接另一方还能继续发送
### 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？
- ACK（确认收到）和 FIN（请求关闭发送）的时机是不确定的：ACK 几乎是立即回复的，FIN 是在 Server 上层应用决定关闭连接并发送完所有数据后才发送的。
> 客户端在发送 FIN 后会启动一个重传计时器。如果在计时器超时之前没有收到服务端的 ACK，客户端会认为 FIN 报文丢失，并重新发送 FIN 报文
- 第二次挥手和第三次挥手的目的不同，第二次的目的是回应客户端的关闭请求的，第三次的目的是通知客户端所有数据已经发送完毕。
> 但在做题中可视为三次挥手来计算
### 为什么第四次挥手需要等待 2MSL时间后才进入 CLOSED 状态？
- 第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN。
- 如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。