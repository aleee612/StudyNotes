p1551,p3367
[952. 按公因数计算最大组件大小 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-component-size-by-common-factor/description/)
[765. 情侣牵手 - 力扣（LeetCode）](https://leetcode.cn/problems/couples-holding-hands/description/)
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1000001;
 
int father[MAXN];  // 每个节点的父节点
int group_size[MAXN];    // 每个集合的大小
int st[MAXN];   // 用于路径压缩的栈
int n;  // 节点数量
 
// 初始化并查集
void build() {
    for (int i = 0; i <= n; i++) {
        father[i] = i;   // 自己是自己的父节点
        group_size[i] = 1;      // 初始大小为1
    }
}
 
// 查找并返回i的根节点，带路径压缩
int find(int i) {
    // 沿途收集路径上的所有节点
    int size = 0;
    while (i != father[i]) {
        st[size++] = i;  // 将当前节点压入栈
        i = father[i];      // 一直往上找
    }
    // 路径压缩，所有节点都直接指向根节点
    while (size > 0) {
        father[st[--size]] = i;
    }
    return i;  // 返回根节点
}
 
// 判断x和y是否在同一集合中
bool isSameSet(int x, int y) {
    return find(x) == find(y);  // 如果根节点相同，则在同一个集合
}
 
// 合并x和y所在的两个集合
void unionSets(int x, int y) {
    int fx = find(x);  // 找到x的根节点
    int fy = find(y);  // 找到y的根节点
    if (fx != fy) {  // 如果x和y不在同一个集合
        // fx是集合的代表：拿大小
        // fy是集合的代表：拿大小
        if (group_size[fx] >= group_size[fy]) {
            group_size[fx] += group_size[fy];  // 合并两个集合
            father[fy] = fx;       // 将fy的根节点指向fx
        } else {
            group_size[fy] += group_size[fx];
            father[fx] = fy;
        }
    }
}
 
int main() {
 
    // 输入处理
    int m;
    while (cin >> n) {  // 读取节点数
        build();  // 初始化并查集
        cin >> m;  // 读取操作次数
        for (int i = 0; i < m; i++) {
            int op, x, y;
            cin >> op >> x >> y;
            if (op == 1) {  // 查询是否在同一集合
                cout << (isSameSet(x, y) ? "Yes" : "No") << endl;
            } else {  // 合并集合
                unionSets(x, y);
            }
        }
    }
 
    return 0;
}
```
- 简单写法：省略小挂大
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1000001;
 
int father[MAXN];  // 每个节点的父节点
int n;  // 节点数量
 
// 初始化并查集
void build() {
    for (int i = 0; i <= n; i++) {
        father[i] = i;   // 自己是自己的父节点
    }
}
 
// 查找并返回i的根节点，带路径压缩
int find(int i) {
    if(i != father[i])
    {
        father[i] = find(father[i]);
    }
    return father[i];
}
//d->d
//c->d->d
//b->c->d => b->d<-c
//a->b-> => a->d
// 判断x和y是否在同一集合中
bool isSameSet(int x, int y) {
    return find(x) == find(y);  // 如果根节点相同，则在同一个集合
}
 
// 合并x和y所在的两个集合
void unionSets(int x, int y) {
    father[find(x)] = find(y);
}
 
int main() {
 
    // 输入处理
    int m;
    while (cin >> n) {  // 读取节点数
        build();  // 初始化并查集
        cin >> m;  // 读取操作次数
        for (int i = 0; i < m; i++) {
            int op, x, y;
            cin >> op >> x >> y;
            if (op == 2) {  // 查询是否在同一集合
                cout << (isSameSet(x, y) ? "Y" : "N") << endl;
            } else {  // 合并集合
                unionSets(x, y);
            }
        }
    }
 
    return 0;
}
```
# 最小生成树
- 模板题：p3366
> 什么是最小生成树？
	权值最小，不能有环
	最小生成树可能不止一个
## kruskal算法：（最常用）
1. 把所有的边，根据权值从小到大排序，从权值最小的边开始考虑
2. 如果连接当前的边不会形成环，就选择当前的边（放入集合）
3. 如果当前的边会形成环，就不要当前的边（已经在集合内）
4. 考察完所有边之后，最小生成树也就得到了
![](https://cdn.nlark.com/yuque/0/2025/png/55555653/1744542180269-0f416cc3-d644-4f7b-924b-4cd33b58d065.png "null")
假设我们给所有的权值编号，由小到大依次为a b c d e f g h：
![](https://cdn.nlark.com/yuque/0/2025/png/55555653/1744542180382-adca3865-5a7c-4fd1-93f7-6017511f9dd0.png "null")
> 那么对于边a，我们可以将1，2合并到一个集合里，成为 { 1, 2 },{ 3 }, { 4 }, { 5 }
 -> b : { 1, 2, 5 } ,{ 3 } ,{ 4 }
 -> c : 可以看到，c连接的1，5已经是在一个集合中，所以我们舍弃不用
 -> d : { 1, 2, 5, 3 }, { 4 }
 -> e : 同c，舍弃
 -> f : { 1, 2, 5, 3, 4}
 -> g, h : 舍弃
- 模板题3366：
![](https://cdn.nlark.com/yuque/0/2025/png/55555653/1744542180458-8e9dcf6f-a4f0-46d4-bc5d-310d6b733b88.png "null")
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
//int edges[200001][3];
vector<vector<int>> edges(200001,vector<int>(3));
int father[10001];
void build()
{
    for(int i=0;i<=10000;i++)
    {
        father[i] = i;
    }
}
int find(int i)
{
    if(i != father[i])
    {
        father[i] = find(father[i]);
    }return father[i];
}
bool Union(int a,int b)
{
    int fa = find(a);
    int fb = find(b);
    //cout << "fa" << fa << " " << "fb" << fb << endl;
    if(fa != fb)
    {
        father[fa] = fb;
        return true;
    }
    return false;
}
bool cmp(vector<int> a,vector<int> b)
{
    return a[2] < b[2];
}
int main()
{
    int n,m,ans = 0,cnt = 1;
    cin >> n >> m;
    build();
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<3;j++)
        {
            cin >> edges[i][j]; 
        }
    }
    sort(edges.begin(),edges.begin()+m,cmp);

    for(int i=0;i<m;i++)
    {
        for(int j=0;j<3;j++)
        {
            if(Union(edges[i][0],edges[i][1]))
            {
                ans+=edges[i][2];
                cnt++;
                //cout << cnt << " " << edges[i][2] << endl;
            }
        }
    }
    if(cnt == n)
    {
        cout << ans << endl;
    }
    else
    {
        cout << "orz" << endl;
    }
}
```
- 注：sort无法直接对二维数组排序（其实也可以就是很麻烦），所以直接使用vector
### 题目练习：
- p1194买礼物
![](https://cdn.nlark.com/yuque/0/2025/png/55555653/1744542180547-50002cd0-1ce2-4253-b3ad-c70a8916537d.png "null")
![](https://cdn.nlark.com/yuque/0/2025/png/55555653/1744542180619-1d907965-e149-4960-9d00-a1797cc8c83f.png "null")
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
vector<vector<int>> edges(250000, vector<int>(3));
int a, b, ans = 0, cnt = 1,num = 0,edgesSize = 0;
int father[1000];
bool cmp(vector<int> a, vector<int> b)
{
    return a[2] < b[2];
}
void build()
{
    for (int i = 0; i <= a; i++)
    {
        father[i] = i;
    }
}
int find(int i)
{
    if (i != father[i])
    {
        father[i] = find(father[i]);
    }
    return father[i];
}
bool Union(int a, int b)
{
    int fa = find(a);
    int fb = find(b);
    if (fa != fb)
    {
        father[fa] = fb;
        return true;
    }
    return false;
}
int main()
{
    cin >> a >> b;
    ans = a;
    build();
    for (int i = 0; i < b; i++)
    {
        for (int j = 0; j < b; j++)
        {
            int w;
            cin >> w;
            if (w != 0 && j > i)
            {
                edges[edgesSize][0] = i;
                edges[edgesSize][1] = j;
                edges[edgesSize][2] = w;
                //cout << edges[edgesSize][0] << "      " << edges[edgesSize][1] << "      " << edges[edgesSize][2] << endl;

                if(w > a)
                    num++;
                edgesSize++;
            }
        }
    }
    sort(edges.begin(), edges.begin() + edgesSize, cmp);
    // for(int i = 0; i < edgesSize; i++)
    // {
    //     cout << edges[i][0] << "    " << edges[i][1] << "    " << edges[i][2] << endl;
    // }
    for (int i = 0; i < edgesSize - num; i++)
    {
        if (Union(edges[i][0], edges[i][1]))
        {
            ans += edges[i][2];
            //cout << edges[i][2] << "  " << edges[i][0] << "  " << edges[i][1] << endl;
            cnt++;
        }
    }
    
    ans += (b - cnt) * a;
    cout << ans << endl;
    return 0;
}
```
扩展：p2330繁忙的都市