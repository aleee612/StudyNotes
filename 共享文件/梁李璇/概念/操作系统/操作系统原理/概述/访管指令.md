---
aliases:
  - 系统调用指令
---
- 作用：**让 CPU 从用户态切换到内核态**，执行一段受保护的内核代码（系统调用）。
- 实现依赖中断
- 非特权指令，但触发特权行为
### 考试重点

| 问题            | 答案     |
| ------------- | ------ |
| 是不是特权指令？      | ❌ 不是   |
| 用户态能不能执行？     | ✅ 能    |
| 会不会进内核态？      | ✅ 会    |
| 进入内核是不是“合法的”？ | ✅ 完全合法 |
#### 执行全过程
以用户进程调用 `read()` 为例：
1. **用户态**
    `read(fd, buf, size);`
2. C 库封装 → 执行 **访管指令**
    `syscall   // 或 int / svc`
3. **CPU 硬件自动做的事**（也就是[[中断#软硬件中断初期差异：|软中断执行部分]]）
    - 保存现场（PC、标志寄存器）
    - **模式位切换：用户态 → 内核态**
    - 查 **中断/异常向量表**
4. 跳转到内核的 **系统调用处理程序**
5. 内核执行真正的 `sys_read` 
6. `return-from-trap`
7. **回到用户态，程序继续跑**
整个过程**自愿、自陷、可控**
#### 和“系统调用”的关系
> 访管指令是系统调用实现过程中的一个不可或缺的步骤
- 系统调用：**操作系统提供的服务**
- 访管指令：**进入内核的“门铃”**
### 不同架构中的访管指令
| 架构         | 访管指令名字（系统调用指令）             |
| ---------- | -------------------------- |
| **x86**    | `int 0x80`（旧）、`syscall`（新） |
| **ARM**    | `SVC`（Supervisor Call）     |
| **RISC-V** | `ecall`                    |
| **MIPS**   | `syscall`                  |
### 例：与Linux中sudo的关系
- 第一步：sudo 读取 /etc/sudoers
	需要文件 I/O → **系统调用**（访管一次）
- 第二步：验证用户密码
	又是 I/O → **系统调用**（访管一次）
- 第三步：切换到 root 身份
	核心：sudo 使用 **setuid(0)** 系统调用，就是 _切换到 root UID（0）_ 的操作
	setuid 是真正的“提权”，而调用它需要执行访管指令 → 内核态 → 修改进程凭证 → 返回用户态
- 第四步：执行你输入的指令
	调用 `execve()` → 又是 **系统调用** → 又是访管指令
