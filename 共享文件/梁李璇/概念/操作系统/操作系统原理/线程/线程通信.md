> **Summary：**
> 线程通信是基于**共享内存**的协作机制，核心问题不是通信本身，而是同步与互斥。  
> 常用手段包括共享变量、共享数据结构，并通过互斥锁、信号量、条件变量等机制保证正确性。
> 线程通信一般需要通过系统调用（但非必须，只是这样做安全）
## 三种通信方式
### 1. 共享变量（最常见）
```c
int count = 0; 
Thread A: count++; 
Thread B: printf("%d", count);
```
- 所有线程都能看到 `count`
- 通信成本 = 0
- 事故概率 = 100%（如果不加保护）
所以：
> 共享变量 = 通信方式  
> 锁 = 保险丝
---
### 2. 共享数据结构
如：
- 全局数组
- 堆上的结构体
- 共享队列 / 链表 / 哈希表
- 生产者线程 -> 队列 -> 消费者线程
这就是经典的 **生产者–消费者模型**
---
### 3. 条件变量 / 信号量（通信 + 同步）
严格说：
- 它们**不传数据**
- 但**传“事件 / 状态”**
比如：
> “我生产完了，你可以消费了”
---
## 线程通信离不开的三件套（重点）
### 互斥（Mutex）
> 保证**同一时刻只有一个线程访问共享资源**
```c
lock(); 
count++; 
unlock();
```
- 防的是数据竞争（Race Condition）
---
### 同步（Synchronization）
> 保证**线程执行顺序正确**
- 如必须先写，再读
- 必须等任务完成
---
### 原子操作（Atomic）
> CPU 保证“不可打断”的最小操作
```c
atomic_inc(&count);
```
- 快
- 但能力有限（只能做简单操作）
---
## 经典线程通信模型
### 生产者 – 消费者
- 通信：共享缓冲区
- 互斥：保护缓冲区
- 同步：缓冲区满 / 空
---
### 读者 – 写者
- 多读 OK
- 写必须独占
- 典型共享数据通信场景
---
### 哲学家进餐（反面教材）
- 展示：
    - 死锁
    - 饥饿
    - 资源竞争
---
## 线程通信为什么比进程简单？

因为：
- 线程通信 ≈ 共享内存 + 同步机制 进程通信 ≈ 共享内存 + 内核帮忙 + 拷贝 + 权限检查
所以才有那句老话：
> **线程快，但容易翻车；进程慢，但稳**
## 不同进程的线程通信
- 不同进程的线程通信和进程通信一样，必须使用系统调用实现
