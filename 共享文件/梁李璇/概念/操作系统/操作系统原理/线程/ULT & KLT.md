**Summary：**
> ULT = 用户级线程
> KLT = 内核级线程
### ULT（User-Level Thread，用户级线程）
**谁管？**  
用户态的线程库（比如 runtime、线程库），**内核不知道你有多少线程**。
**特点：**
- 线程创建 / 切换：**不进内核，快**
- 内核眼里：**整个进程就一个执行实体**
- 一个线程阻塞（如系统调用）：  
    **整个进程一起卡住**
**优点：**
- 切换快（不陷入内核）
- 线程数量多也不怕（内核不管）
**缺点（致命）：**
- **不能利用多核**（内核只调度进程）
- 一个阻塞，**全员罚站**
典型例子：
- 早期 Java Green Threads
- 某些语言运行时的纯用户态协程（不映射内核线程）
---
### KLT（Kernel-Level Thread，内核级线程）
**谁管？**  
操作系统内核
**特点：**
- 每个线程内核都知道
- 内核直接调度线程
**优点：**
- 能跑在多个 CPU 核心上
- 一个线程阻塞，**不影响其他线程**
**缺点：**
- 创建 / 切换线程：要进内核，**慢一点**
- 内核管理成本更高
典型例子：
- Linux `pthread`
- Windows 线程
- 你平时写的多线程程序，**基本都是 KLT**
- ---
### 多线程模型：ULT与KLT之间的映射
![[Pasted image 20251215200829.png]]
> ULT 和 KLT 是两个不同层面的“实体”，  
> 它们之间只有“映射关系”，没有“状态切换”。
> ULT运行在线程库，CPU内核无法直接与其交互，所以需要使用ULT与KLT的映射来进行控制
#### 多对一（Many-to-One）
**特点**
- 所有 ULT 都跑在 **一个 KLT** 上
- 线程调度 **完全在用户态**
- 一个线程阻塞（系统调用）→ 全部阻塞
**优点**
- 切换快（不进内核）
**致命缺点**
- 无法利用多核
- 阻塞灾难
例： Java 早期 Green Threads
#### 一对一（One-to-One）
**特点**
- 一个 ULT 对应一个 KLT
- OS 直接调度 KLT
- 真·并行（多核）
**优点**
- 阻塞互不影响
- 真并发
**缺点**
- KLT 创建 / 切换成本高
例：Linux pthread（主流）
#### 多对多（Many-to-Many）
**特点**
- ULT 数量 ≥ KLT 数量
- 线程库把 ULT 分配给空闲 KLT
- OS 只管 KLT，不知道 ULT
**优点**
- 兼顾性能 + 并发
- 阻塞可控
**缺点**
- 实现复杂（调度器套调度器）
理论很美，现实很少用
---
### ULT与KLT各自的切换
#### 1:1 模型（典型 Linux/Windows）
- 每个 **ULT** 对应一个 **KLT**
- **切换 ULT = 切换 KLT**
    - 线程库调度一个 ULT → 内核调度对应 KLT → CPU 执行
    - 阻塞、抢占、抢占调度都是由内核完成
- 优点：简单，阻塞不会影响其他线程，多核可利用
- 缺点：创建/切换成本高（要进内核）
**状态切换流程**：
CPU执行 KLT-A（对应ULT-A）
-> 线程库/内核决定调度 
-> 保存 KLT-A 上下文（寄存器、堆栈）
-> 恢复 KLT-B 上下文（对应ULT-B） 
-> CPU执行 KLT-B（对应ULT-B）
#### M:N 模型（混合模型，比如 Go runtime goroutine）
- 用户态：N 个 **ULT（goroutine）**
- 内核态：M 个 **KLT（内核线程）**
- **ULT切换** → 只在用户态完成，不涉及内核（快）
- **KLT切换** → 由内核调度（慢）
- 用户态线程库负责把多 ULT 映射到少量 KLT 上跑
**状态切换流程**：
用户态线程库调度：
ULT-1（挂在KLT-1上） 
→ 保存 ULT-1 上下文 
→ 恢复 ULT-2 上下文 
→ 继续跑 KLT-1  
内核切换： KLT-1 阻塞或被抢占 
→ 内核调度 KLT-2 
→ KLT-2 上的 ULT 执行
#### 关键点：
- **ULT切换**：不进内核，非常快
- **KLT切换**：进内核，影响调度和多核利用
- **阻塞情况**：
    - 只阻塞 ULT → 用户态线程库可以调度其他 ULT
    - KLT 阻塞 → 内核会调度其他 KLT 上的线程
可以理解成：
> **ULT切换 = 轻量切换**  
> **KLT切换 = 重量切换**  
> M:N 模型里，ULT多对KLT少，轻量切换更灵活，高并发友好