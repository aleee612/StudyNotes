### 1. 软件工程的定义 (1.2.1)

**IEEE 在 1993 年给出的软件工程定义**是：

1. **将系统的、规范的、可量化的方法应用于软件的开发、运行和维护**；
2. 即**上述方法应用于程序设计的研究、运行和维护**。

软件工程的第二部分定义说明了软件工程需要相关的**科学研究**做基础，需要**方法学**的支持。
### 2. 软件工程的五要素 

根据来源，软件工程活动涉及到的五个基本要素包括：

1. **方法和工具** (Software Methods and Tools)
2. **过程** (Process)
3. **人**
4. **软件项目管理** (Software Project Management)
5. **环境** (Environment)

软件工程的五要素构成了如图 1.4 所示的相互关联的关系图。
### 2. 软件工程的模型

软件过程模型描述了软件开发活动的组织和属性之间的逻辑关系。常用的软件过程模型主要包括：

- **瀑布模型：** 是一种**线性顺序模型**。它将软件开发过程分为需求、设计、编码、测试、运行、维护等阶段，要求每个阶段都必须完整且严格地进行，并产生相应的文档。其优点是思路清晰、易于管理，但缺点是缺乏反馈，对需求的变更是适应性差。
- **增量模型：** 在瀑布模型的基础上，通过**增量**不断发布新的软件版本，可以及时获得用户的反馈。
- **原型建造模型：** 通过**快速构建原型**来帮助用户更准确地确定需求。原型模型主要有两种：**提炼型原型**（一次性使用）和**演化型原型**（将原型逐步精化为系统的一部分）。
- **螺旋模型：** 是一种**迭代模型**，引入了**风险分析**作为核心。它将软件过程分为**确定目标、风险分析、开发和验证、制定规划**四个象限。螺旋模型特别适合大型项目或需求不确定性高的项目。

### 2. 面向对象的概念

面向对象的开发方法学与人类的思维习惯一致，其核心概念包括：

1. **对象（Object）：** 客观世界中个体或事物的抽象，是属性及其相关操作的**封装**。
2. **类（Class）：** 是对象的抽象描述，即具有相同特征的**模板**。
3. **继承（Inheritance）：** 类之间的层次关系，子类可以**共享**父类的属性和操作。
4. **封装（Encapsulation）：** 将对象的**属性和操作绑定在一起**，并保护对象内部数据的安全性。
5. **多态（Polymorphism）：** 一个接口可以对应多种实现形式。
6. **消息（Message）：** 消息传递是对象与其外部世界相互关联的唯一途径
7. **聚合**：部分类的对象是整体类的对象的组成部分
### 3. UML的五种图形机制

UML（统一建模语言）是面向对象建模的**图形化表示机制**。它定义了以下五类图形机制：

1. **用例视图/机制：** 描述系统的功能，从**外部用户**的角度描述系统功能，用**用例图**来表示。
2. **结构视图/机制：** 描述系统的**静态结构**，包括**包图、类图和对象图**。
3. **行为视图/机制：** 描述系统的**动态行为**，包括**交互图、状态图和活动图**。
4. **构件视图/机制：** 描述软件系统中**各组成构件**的静态结构，用**构件图**表示。
5. **部署视图/机制：** 描述软件系统在**物理运行环境**中的分布情况，用**部署图**表示。

### 4. 各种RUP的作用

RUP（统一过程）是一种**迭代式、增量式**的软件开发方法。它将软件开发过程划分为**5 个阶段**和**9 个工作流**。

**RUP 的 5 个阶段（软件的进化状态）：**

1. **初始阶段：** 定义项目范围、确定**业务用例和基本需求**，并建立初步的系统架构基础。
2. **细化阶段：** **精化需求**、建立稳定的**软件体系结构**、并修正项目计划和风险评估。
3. **构造阶段：** **实现**设计模型，进行编码、单元测试、集成测试，并产生可执行的产品。
4. **移交阶段：** 将软件提交给最终用户（部署、安装、用户培训）。
5. **生产阶段：** 软件在实际环境中运行，进行**维护和演化**。

**RUP 的 9 个工作流（项目活动）：** 包括**业务建模、需求、设计、实现、验证与确认（V&V）、部署、配置和变更管理、项目管理、环境**。这些工作流支持了跨越 5 个阶段的开发活动。

### 5. 软件需求的分类

软件需求通常根据对目标系统的期望，划分为三类：

1. **功能需求：** 描述目标软件系统应该提供的**功能**。
2. **质量需求：** 描述软件系统**除功能之外的质量属性**，如性能、可靠性、安全性、易用性、可移植性等。
3. **约束性需求：** 限制项目预算、时间、技术选型或必须遵守的标准，是软件开发必须遵循的**前提条件**。

### 6. 4.1的用例图和类图知识

#### 4.1.1 & 4.1.2 用例和用例图

- **用例图 (Use Case Diagram):** 从**外部用户（执行者）**的角度描述系统提供的一系列**功能**。
- **执行者 (Actor):** 与系统进行交互的外部实体，可以是人或外部系统。
- **用例间的关系:** 主要有三种：
    - **包含关系 (`<<include>>`):** 表示用例 A **必须**包含用例 B 的功能。通常用于提取公共功能。
    - **扩展关系 (`<<extend>>`):** 表示用例 A 在**特定条件**下才会执行用例 B 的功能。
    - **继承关系:** 表示用例的**特殊化**。
- **布局规则：** **主动执行者**（信息的触发者）通常置于**左侧**，**被动执行者**置于**右侧**。用例倾向于**垂直方向排列**。

#### 4.1.4 类图

- **类图作用：** 描述面向对象系统的**静态结构**，在需求阶段用于创建**领域概念模型**。它展示了类、属性、操作以及类之间的关系。
- **类的元素：** 类包括**类名**、**属性**和**操作**。
- **类间的关系：**
    - **关联、聚集和组合：** 关联（Aggregation，共享）、组合（Composition，独占）描述了**整体与部分**的关系。
    - **继承（泛化）：** 表示**“是一种”**的关系，用于共享属性和操作。
    - **依赖：** 表示一个类的变化可能影响到另一个类。
    - **多重性：** 用数字或符号表示一个类的实例与另一个类的多少个实例相关联。

### 7. 活动图是什么

活动图 (Activity Diagram) 是一种 UML 图形，用于描述**某个业务功能或操作的执行序列**。

- **特点：** 它主要侧重于描述**控制流和信息流**，特别适合描述具有**并发、分枝或同步**的复杂过程。
- **核心元素：** 包括**活动**（基本的计算步骤）、**决策节点**（分支）、**分岔/汇合节点**（并发/同步）和**控制流**。
- **泳道机制：** 活动图可以使用**泳道**来划分活动，明确**不同角色或组织**负责的活动。

### 8. 第五章两个图侧重点都是做什么的

第五章《需求分析与验证》中，重点的两个交互图是**顺序图**和**通信图**。

| 图形                              | 侧重点            | 描述内容                                                  |
| :------------------------------ | :------------- | :---------------------------------------------------- |
| **顺序图 (Sequence Diagram)**      | **消息传递的**时间顺序。 | 强调对象间的**消息发送和接收的先后次序**。通过**垂直的生命线**和**激活期**来表示对象间的交互。 |
| **通信图 (Communication Diagram)** | **对象之间的协作关系**。 | 强调参与交互的**对象之间的连接器**，显示对象如何通过连接通信。                     |
|                                 |                |                                                       |

简而言之，**顺序图**侧重于“**什么时候**发生了什么”；**通信图**侧重于“**谁和谁**一起完成了什么”。在分析模型中，顺序图由于强调时间次序，在建模时通常具有更高的优先级。

### 9. 状态图怎么画

状态图 (Statechart Diagram) 描述**对象在生命周期内因事件触发而发生的动态状态和响应**。

**主要绘制步骤和规则：**

1. **确定状态节点：** 确定对象在生命周期中可能拥有的**静止**状态。
2. **绘制初始态和终态：** 每个顶层状态图有一个**初始态**（实心黑点）和**终态**（带圆圈的实心点）。
3. **绘制迁移 (Transition)：** 用带**箭头**的线段连接状态节点。迁移的触发通常由**事件**、**监护条件**和**动作**组成。
4. **定义迁移标签：** 迁移标签格式为 `事件名 [监护条件] / 动作`。监护条件和动作是可选的。
5. **结构化绘制：** 对于复杂状态，可以绘制**复合状态**，复合状态中可以包含**子状态**，子状态之间可以是**并行**（AND）或**互斥**（XOR）关系。
6. **布局规则：** 初始态位于左上方，终态位于右下方。迁移线应绘制成**水平线或垂直线段**组合的折线，避免斜线。

### 10. 132页扩充机制 (UML 扩展机制)

UML 扩展机制（位于 5.1.4 节）是为了**增强 UML 模型的表达能力**，弥补标准 UML 语法**无法表达的精细语义**。它包含三个核心机制：

1. **约束 (Constraint):** 可以附加到任何 UML 元素上，用**花括号 `{}`** 括起来，用于表达**语义限制**或**规则**。
2. **标记 (Tagged Value):** 是一种**名值对**，用于附加额外的**语义信息**，通常用 `name=value` 的形式表示。它可用于指示**设计和实现**的影响。
3. **构造型 (Stereotype):** 用**双尖括号 `<< >>`** 表示，允许在 UML 标准语法的基础上添加**建模者自定义的语义**，用于表示特定的角色或语义。例如，RUP 中使用的**边界类、控制类和实体类**就是构造型的应用。

### 11. 140页分析类的作用和各种概念

（根据来源内容，第140页对应 5.4.2 节的 **设置分析类** 及其概念）

**分析类的作用：** 分析类是指直接服务于软件**功能需求**的概念层面的类。它们作为**领域逻辑处理功能**的载体，帮助将业务逻辑划分为不同的职责。通过设置分析类，可以将**自然语言描述**的需求转换为**更接近于软件设计模型**的结构。

**分析类的三种构造型概念：** 分析类通常被划分为边界类、控制类和实体类三种**构造型**：

1. **边界类 (Boundary Class) `<<boundary>>`：**
    
    - **作用：** 负责处理**目标软件系统与外部执行者之间**的交互。边界类是系统与外界的**接口**。
    - **举例：** 用户界面、外部系统接口和环境隔离层。
2. **控制类 (Control Class) `<<control>>`：**
    
    - **作用：** 负责**协调、控制**其他类共同完成用例规定的功能，并**封装用例的业务逻辑**。通常一个用例对应一个控制类。
3. **实体类 (Entity Class) `<<entity>>`：**
    
    - **作用：** 承载目标软件系统中**持久保存**的**业务信息**，即那些需要长期存储或持久化数据的实体。
    - **举例：** 在家庭保安系统中，如“日志”或“传感器”就是实体类。

这三类分析类共同协作，将用户输入通过**边界类**接收，由**控制类**进行协调和处理，最终操作**实体类**中的持久数据。

您好！以下是针对您提出的七个问题的全面总结，内容均来源于您提供的资料，旨在帮助您备考期末考试。





### 3. 软件工程的目标和原则 (1.2.3)

#### 软件工程的目标

软件工程的目标是在**给定成本、进度的前提下**，开发出**满足用户或市场需要的高质量的软件产品**。

#### 软件工程的原则

为了达到上述目标，在软件开发过程中必须根据软件系统的功能、特点和实际情况，遵循以下**软件工程原则**：

1. **抽象（Abstraction）**：提取事物最基本的特性和行为，忽略非基本的细节。
2. **信息隐藏（Information Hiding）**：模块对外部隐藏其内部数据和操作的实现细节，提高系统的**可理解性**和**开发过程的管理**。
3. **模块化（Modularity）**：将程序组织为**相互独立**的部件（模块），每个模块是一个**独立的逻辑实体**。模块化有助于信息隐藏。
4. **局部化（Localization）**：将散的资源集中于一个物理模块中，便于控制与维护。
5. **一致性（Consistency）**：在整个软件生命周期中，**所有阶段的各项产物都使用一致的概念、符号、术语和结构**，保证软件与过程的保持一致性。
6. **完整性（Completeness）**：软件系统**完整实现**了所允许的**所有功能**。
7. **可验证性（Verifiability）**：开发大型软件时，需要进行**“分而治之”**，软件的每个阶段产物都应**易于验证**。

### 4. 软件需求的分类 (3.1.1)

软件需求根据利益相关方对目标软件系统的期望和要求，可分为三种类型：

1. **功能需求（Functional Requirements）**：描述目标软件系统**应该提供的功能**。
2. **质量需求（Quality Requirements）**：描述软件系统的**质量属性**，是除功能之外的软件特性，如性能、可靠性、安全性等。
3. **约束性需求（Constraint Requirements）**：限制项目预算、时间、技术选型或必须遵守的标准，是软件开发必须遵循的**前提条件**。约束性需求是实现质量需求的前提条件。

### 5. 通信图相关知识 (5.1.2)

通信图（Communication Diagram）是 UML **交互图**的另一种表现形式。

- **作用：** 通信图描述了参与交互的**对象之间的协作关系**。它是**顺序图的另一种表现形式**，通常在语义上与顺序图**等价**。
- **侧重点：** 通信图强调参与交互的**对象之间的连接器**。
- **元素：** 通信图的节点是参与交互的**对象**，其表示方法与顺序图相同。
- **对象间连接：** 对象之间的连接称为**连接器**，它扮演着消息通道的角色。连接器可以是**有向**或**无向**的，有向连接器只能沿连接器的方向传递消息。
- **消息编号：** 通信图使用**多层结构化的编号**来标记消息传递的**次序**，例如，`1.1`、`1.2` 等。
- **布局规则：** 对象在通信图中可以**自由定位**。通常推荐的布局规则是，如果用例有**主动对象**，应位于图的**左上部**；**被动对象**位于**右侧**。

### 6. 状态图相关知识 (5.1.3)

状态图（Statechart Diagram）用于描述**对象在生命周期内因事件触发而发生的动态状态和响应**。

- **作用：** 状态图描述了**对象的所有可能状态**、在每个状态下的**响应**，以及事件发生时的**状态变迁**。它特别适用于描述那些具有**复杂行为特征**且其行为依赖于**当前状态**的对象。
- **基本概念：**
    - **状态（State）：** 对象在其生命周期中因事件触发而处于的**静止状态**。
    - **事件（Event）：** 导致对象从一个状态**迁移**到另一个状态的**刺激或触发条件**，包括信号事件、调用事件、时间事件和变更事件。
    - **迁移（Transition）：** 状态之间的带**箭头**的线段，表示状态的改变。迁移可包含**事件、监护条件和动作**。
    - **初始态（Pseudo State）**：每个顶层状态图有一个**初始态**，表示对象开始时的第一个状态。
    - **终态（Final State）**：表示对象生命周期的终结。
- **迁移标签格式：** 迁移标签的格式为：`事件名 [监护条件] / 动作`。
- **结构化机制：** UML 支持**复合状态**，复合状态中包含**子状态**。子状态可以是**互斥**（XOR）的，也可以是**并行**（AND）的。
- **布局规则：** **初始态**应位于**左上方**，**终态**位于**右下方**。迁移边应绘制成**水平线段**、**垂直线段**组合的折线，避免斜线。

### 7. 扩充机制 (5.1.4)

UML 的扩充机制是为了解决**标准 UML 语法无法完全表达所有语义**的问题，用于**增强 UML 模型的表达能力**，弥补标准 UML 图形的不足。它包括以下三种机制：

1. **约束 (Constraint)：**
    - **表示方法：** 用**花括号 `{}`** 括起来。
    - **作用：** 附加在任何 UML 元素上，用于表示**逻辑限制**或**语义限制**。
2. **标记 (Tagged Value)：**
    - **表示方法：** 一种**名值对**的形式 `name=value`。
    - **作用：** 用于附加**额外的语义信息**，通常用于指示设计和实现的影响。
3. **构造型 (Stereotype)：**
    - **表示方法：** 用**双尖括号 `<< >>`** 括起来。
    - **作用：** 允许建模者在标准 UML 元素的基础上**添加自定义的语义**，用于表示特定的角色或语义。例如，分析模型中使用的**边界类** `<<boundary>>`、**控制类** `<<control>>` 和**实体类** `<<entity>>` 就是构造型的应用。
### 1. 软件设计模型 (Software Design Models)

软件设计模型是针对工程提出的软件需求，综合考虑各种制约因素后，设计人员**寻找可行的软件解决方案**的逻辑表示。软件设计模型是**连接需求与实现**之间的“桥梁”。

典型的软件设计模型一般包括：

- **体系结构模型**（System Structure Model）
- **用户界面模型**（User Interface Model）
- **用例模型**（Use Case Model）
- **数据/类模型**（Data/Class Model）
- **子系统/构件模型**（Subsystem/Component Model）
- **类型/类模型**（Type/Class Model）

设计模型主要关注**如何实现**软件需求，即它负责将用户需求转化为**可执行的软件系统**。

### 2. 软件设计的基本原则 (Fundamental Principles of Software Design)

为了开发出高质量的软件设计模型，在设计过程中必须遵循以下基本原则：

1. **抽象与逐步求精（Abstraction and Stepwise Refinement）：**
    
    - **抽象**：提取事物最基本的特性和行为，并**忽略非基本的细节**。
    - **逐步求精**：在不同抽象级别上，**自上而下**地将宏观设计逐步细化到实现层面的元素。
2. **模块化（Modularity）：**
    
    - 将程序组织为**相互独立**的部件（模块），每个模块应是**独立的逻辑实体**。
    - 模块化有助于**提高系统的可理解性**和**调试复用**，但模块过多或过大都会带来负面影响。
3. **强内聚与松耦合（Strong Cohesion and Loose Coupling）：**
    
    - 这是最经典的设计原则之一。
    - **内聚（Cohesion）**：模块内部各元素之间**逻辑关联的强度**，强内聚要求模块只完成**单一、简单的职责**。
    - **耦合（Coupling）**：模块之间**相互连接的强度**，松耦合要求模块间的接口**尽可能简单**。
    - 强内聚与松耦合有助于提高软件的**可维护性、可修改性和可复用性**。
4. **信息隐藏（Information Hiding）：**
    
    - 模块对外部隐藏其**内部数据和操作的实现细节**。
    - 信息隐藏能增强软件的**模块独立性**，**降低调试和测试的工作量**，并提高系统的**可理解性**。
5. **关注点分离（Separation of Concerns）：**
    
    - 指将设计问题聚焦于**概念或目标**的基本部分或侧面。
    - 将复杂问题**分解**为更小的、相互独立或关联较弱的部分，是应对大型复杂软件开发的基本方法。

### 3. 软件测试方法 (Software Testing Methods)

软件测试方法根据其设计和实施的依据，主要分为两类：

1. **白盒测试（White-Box Testing）：**
    
    - **依据**：测试基于程序内部的**逻辑结构**和**代码**，关注程序的执行路径。
2. **黑盒测试（Black-Box Testing）：**
    
    - **依据**：测试基于**软件需求**和**外部可见功能**，忽略程序内部结构。

### 4. 软件测试活动的各种步骤都是干什么的

软件测试活动通常是按照软件开发过程的产物和阶段顺序进行的。根据索引，主要的测试活动（或阶段）包括：

1. **单元测试（Unit Testing）：** 针对程序中的**最小可测试单元**进行验证。
2. **集成测试（Integration Testing）：** 验证**集成后的模块或构件之间**的接口和相互作用是否正确。
3. **确认测试/系统测试（System Confirmation Testing）：** 验证**整个集成后的系统**是否满足系统需求**规范**。
4. **验收测试（Acceptance Testing）：** 最终由**客户或用户**验证系统是否满足**合同**或**用户实际需求**。
5. **面向对象的测试（Testing of Object-Oriented Software）：** 针对面向对象系统特性（如类、交互、继承）进行特定的测试。

### 5. 软件维护的概念和分类

#### 概念

软件维护是指在软件产品**交付使用之后**，对其进行的**修改、改进和适应**等活动。维护是软件**持续进化**的一部分。

#### 分类

软件维护通常分为四种类型：

1. **改正性维护（Corrective Maintenance）：** 用于**诊断和改正**软件产品在运行过程中发现的**缺陷**。
2. **适应性维护（Adaptive Maintenance）：** 用于修改软件，使其能够适应**变化后的运行环境**（如新的操作系统、硬件或外部系统）。
3. **完善性维护（Perfective Maintenance）：** 用于根据用户或市场**新的需求**，**改进**软件的功能、性能或其他质量属性。
4. **预防性维护（Preventive Maintenance）：** 实施修改以**提高软件未来的可维护性、可靠性或质量**。

### 6. 维护的副作用

软件维护活动本身可能会带来一些负面影响，即维护的副作用。主要表现为：

- 由于软件的**逻辑关系复杂**，且**难于理解**，在维护过程中**很可能产生新的缺陷**（引入新的错误）。
- 维护活动可能导致原有的**程序结构和设计被破坏**，使系统**复杂化**，进而影响软件的**可维护性**。

软件就像一栋老房子，当你试图去修补或升级某个房间（改正性维护或完善性维护）时，如果对其结构不够了解（逻辑关系复杂），很有可能在不经意间破坏了地基或承重墙，从而引入新的结构性问题（维护的副作用）。