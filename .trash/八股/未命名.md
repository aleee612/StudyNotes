# Spring

## 谈谈Spring框架
他是一个开源的轻量级java框架。
一般说spring框架都指的是spring framework，是很多个模块的集合，比如AOP，IOC。
最核心的思想实际上就是不重新造轮子，开箱即用。

## 列举一些重要的模块？
Core Container ：IOC 
AOP：aspect，aop
Test：对单元测试JUnit、Mockito等常用测试框架支持
Web：有对MVC的实现，对WebSocket的支持。

## Spring中Bean的作用域

| 作用域                     | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| singleton                  | **容器中唯一的 Bean 实例**（默认）。                         |
| prototype                  | **每次获取都会创建新实例。** 也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。 |
| request                    | 每次 HTTP 请求创建新实例（仅 Web 应用）。                    |
| session                    | 每次 HTTP Session 创建新实例（仅 Web 应用）。                |
| application/global-session | 每个 Web 应用启动时创建一个实例（仅 Web 应用）。             |
| websocket                  | 每次 WebSocket 会话创建新实例（仅 Web 应用）。               |

## 注入Bean的方式
依赖注入 (Dependency Injection, DI) 的常见方式：
1. 构造函数注入：通过类的构造函数来注入依赖项。
2. Setter 注入：通过类的 Setter 方法来注入依赖项。
3. Field（字段） 注入：直接在类的字段上使用注解（如 @Autowired 或 @Resource）来注入依赖项。

## 实现Bean的方式
1. xml：<bean>标签和工厂标签
2. 注解：@Component、@Repository、@Service等
3. Java配置类：@Configuration+@Bean手动创建bean逻辑

## Spring事务及失效场景
**Spring框架事务管理 (@Transactional)**

### 作用 
保证业务层面的**原子性**

### 功能
**简化开发** ：开发者无需编写 `connection.commit()`、`connection.rollback()`、`connection.close()` 等手动事务管理代码。只需通过 `@Transactional` 即可声明事务边界。

### 应用场景
1. `commentMapper.insert(comment);` (插入评论)
2. `videoStatsService.updateStats(...)` (更新视频统计)

如果第一步成功，但第二步因某种原因失败（如网络、死锁、异常），事务管理器会自动回滚第一步的插入操作，确保数据库中不会出现“评论已插入但统计数未更新”的一致状态。

### 失效情况
**1、Spring事务失效原因：**
Spring事务是根据AOP实现的，就是拿到代理对象加入事务逻辑，所以如果调用方式不是通过注入调用的，也就是没有被Spring容器管理，就会失效。
比如一个类的一个非事务方法调用事务方法，事务失效，没走容器。
* **解决：**把被调用的事务方法写到一个新service通过注入调用。

**2、修饰符问题：**
方法不是`public`修饰符。

**3、异常类型问题：**
抛出的异常类型是检查型异常，或者根本没写抛异常语句。

## @Component和@Bean区别

| **特性** | @Component                                  | @Bean                                                        |
| ------------ | ------------------------------------------- | ------------------------------------------------------------ |
| **作用目标** | 类                                          | 方法                                                         |
| **控制权** | **Spring 自动管理** | **开发者手动控制** |
| **使用条件** | 配合 **组件扫描** (`@ComponentScan`) 使用。 | 必须在带有 **`@Configuration`** 或 `@Component` 注解的类中使用。 |
| **创建过程** | spring 通过**反射**自动创建对象并注入依赖。 | 开发者在方法体内**手动实例化**对象，并将对象返回给 spring容器。 |
| **依赖注入** | `@Autowired` 或 `@Resource` 注解。          | 在方法参数中声明依赖，spring 会自动传入。                    |
| **适用场景** | 绝大多数**自定义的类**。                    | 1. **集成第三方库**（无法修改源码）。 2. **需要复杂初始化逻辑**。 3. **需要基于条件创建 Bean**。 |
| **衍生注解** | `@Service`, `@Controller`, `@Repository`    | 无                                                           |

# SpringBoot

## 三者关系
Spring：依赖注入、解耦 (AOP/IOC)
MVC：Spring的一个模块，注解开发的核心，比如Controller，requestmapping等
SpringBoot：快速开发的脚手架

## 有什么优点？
1. 提升开发效率：自动配置，起步依赖，开箱即用的功能
2. 和Spring生态集成
3. Spring Boot 能够根据项目依赖自动配置大量的常见组件（如数据源、Web 容器、消息队列等），提供合理的默认设置。同时也允许开发者根据需要轻松覆盖或定制配置，极大减少了繁琐的手动配置工作。
4. 内嵌web服务器
5. 适合微服务架构
6. Spring Boot 为常用的构建工具（如 Maven 和 Gradle）提供了专门的插件

## 自动装配原理
自动装配机制是通过 `@SpringBootApplication` 启动的，这个注解本质上是三个注解的集合：`@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。

- **@EnableAutoConfiguration**: 启用 Spring Boot 的自动配置机制。它是自动配置的核心，允许 Spring Boot 根据项目的依赖和配置自动配置 Spring 应用的各个部分。
- **@ComponentScan**: 启用组件扫描。描被 @Component（以及 @Service、@Controller 等）注解的类，并将这些类注册为 Spring 容器中的 Bean。默认情况下，它会扫描该类所在包及其子包下的所有类。
- **@Configuration**: 允许在上下文中注册额外的 Bean 或导入其他配置类。它相当于一个具有 @Bean 方法的 Spring 配置类。

### 过程
1. 启动：@SpringBootApplication，标记启动类，开始激活装配
2. 扫描：@ComponentScan+@AutoConfigurationPackage，扫描组件
3. 发现：@Import(AutoConfigurationImportSelector.class)，发现配置清单（位于META-INF/spring.factories）
4. 判断：配置清单上的每一个自动配置的类都会有一个**@ConditionalXXXX**这样的注解，用来判断需不需要装配。
5. 注册：**ConfigurationClassPostProcessor类**，解析通过上面的判断的自动配置类，然后把配置类内部的@Bean方法转化成BeanDefiniton注册到Spring容器里面。

## Spring的循环依赖问题

### 出现原因
一个类初始化的时候需要另一个类的实例，反过来也是。

### 框架怎么解决的
Spring默认是支持自动解决单例的循环依赖问题的，关键在于**提前暴露**。

| 缓存层级 | Map名称                 | 存储内容                                                     |
| :----------- | :---------------------- | :----------------------------------------------------------- |
| **一级缓存** | `singletonObjects`      | 存储**完整、初始化完毕**的单例Bean。                         |
| **二级缓存** | `earlySingletonObjects` | 存储**提前暴露**的Bean实例，可能是代理对象或原始对象。       |
| **三级缓存** | `singletonFactories`    | 存储一个**工厂对象**（逻辑），负责判断要不要代理并返回。     |

### 框架不能解决的
1. **构造器互相注入**：因为构造器创建bean的时候DI和实例化是一个步骤。
2. **Prototype作用域**：三级缓存是为单例模式设计的。

## Bean的生命周期
1. **实例化（Instantiation）**：通过反射创建原始实例。
2. **属性赋值（Populate Properties）**：依赖注入（@Autowired等）。
3. **初始化（Initialization）**：
    - Aware接口回调。
    - BeanPostProcessor前置处理。
    - InitializingBean/自定义init-method。
    - BeanPostProcessor后置处理（AOP代理通常在此生成）。
4. **使用（In Use）**
5. **销毁（Destruction）**

## 谈谈对IOC的理解
控制反转：把对象创建和管理的权利交给Spring容器。解决了对象间的强耦合问题，资源更容易管理（如单例）。

## 谈谈对AOP的理解
面向切面编程：把横切关注点（日志、事务、权限）从核心业务逻辑中分离。
实现机制：基于**动态代理**。
- **JDK动态代理**：要求目标类必须实现接口，生成代理类是“兄弟关系”。
- **CGLIB动态代理**：通过继承实现，生成代理类是“父子关系”。
SpringBoot 2.x 后默认强制使用 CGLIB 以减少注入失败风险。