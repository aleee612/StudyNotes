 ## 总体

### 项目是做什么的？

#### 秒杀系统

主要核心在于，库存数据一致性和高并发的流量

**双层流量防御体系：**

- **入口保护：** 使用 Guava 的 **令牌桶** 算法 (`tryAcquire()` 非阻塞模式) 对接口进行单机限流，保护应用实例自身的线程资源不被耗尽。
- **下游保护：** 引入 **Kafka** 作为消息队列，实现 **削峰填谷** 和 **异步落库**，将瞬时的高并发写入转化为下游数据库可承受的恒定速率。

**原子化库存扣减：** 采用 **Redis + Lua 脚本** 对库存进行原子化操作，避免并发超卖，并利用 **MySQL 任务表** 配合定时任务，解决了 Redis 与 MySQL 之间的数据最终一致性问题。

#### 视频系统

主要核心在于，实时通信，多媒体异步处理

**实时通信核心（Netty）：** 引入 **Netty + WebSocket** 构建了高效的 IM 聊天系统，解决了传统 HTTP 轮询的延迟和性能问题，并实现了多端同步和在线状态管理。

**多媒体异步处理（FFmpeg）：** 实现了视频上传的 **OSS 分片上传与断点续传**，并将耗时的视频转码（FFmpeg + HLS 格式）流程**异步化**，通过 Kafka 投递任务，保证了用户上传体验。



## 秒杀

### 如何防止超卖的

**预扣库存：** 为了抗住高并发，我没有直接查数据库，而是将库存预热到 Redis 中。

**原子性保证：** 使用 **Lua 脚本**执行“查询+扣减”操作。因为 Redis 是单线程执行脚本的，这样能保证在检查库存和扣减库存之间不会有其他线程插入，避免了并发下的超卖问题。

**Kafka异步落库：** Redis 扣减成功后，并不直接写 MySQL，而是通过任务表记录一条任务日志（PENDING待处理）并发送消息到 Kafka。

**最终一致性： **消费者收到消息后更新 MySQL 库存。如果中间失败，我有定时任务扫描“PENDING”状态过久的任务进行重试或回滚 Redis，保证最终一致性

### 为什么选择令牌桶而不是漏桶

漏桶算法更适合平滑流量，以匀速处理请求，不适合这种秒杀场景，令牌桶更适合突发流量秒杀这种

实现方式就是Guava 的RateLimiter，基于令牌桶的算法，通过 `tryAcquire()` 非阻塞地获取令牌，拿不到令牌那当前线程**立即返回 `false`**，不会进入等待状态，代码继续往下执行。

### 引入Kafka有什么作用

削峰：令牌桶放行了高并发，但这些被放行的请求仍然是瞬间爆发的。Kafka 作为一个巨大的**异步缓冲池**，能够瞬间接收所有被放行的请求，并允许下游的消费者以一个**恒定且安全**的速率（比如每秒只处理 50 个订单）进行拉取和处理。这才是对 **MySQL 数据库**真正的削峰，因为它将瞬时的并发写入**平滑**成了长时间的均匀写入

解耦：时间上线程不需要等待数据库写入完成，缩短了响应时间；系统上即使订单服务宕机了，数据也不会丢失，因为在kafka中排队等待。

### 消息丢失怎么办

因为引入了任务表，在把消息发送给kafka之前，就现在任务表中记录状态为PENDING，消费成功的时候再修改状态

如果Kafka消息丢失了或者失败了，后台有定时任务扫描状态是PENDING的记录进行重发。
