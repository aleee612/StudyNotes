### 系统调用（System Call）
- **定义**：系统调用是用户程序向操作系统内核请求服务的接口。它提供了访问硬件或操作系统受保护资源的方式。
- **特点**：
    1. **特权级切换**：系统调用通常涉及从用户态切换到内核态，因为操作系统内核有对资源的完全控制。
    2. **安全**：用户程序不能直接访问硬件或敏感资源，必须通过系统调用。
    3. **开销大**：由于涉及用户态 ↔ 内核态切换，系统调用比普通函数调用慢。
- **例子**：
    - 文件操作：`open()`, `read()`, `write()`, `close()`
    - 进程管理：`fork()`, `exec()`, `exit()`
    - 内存管理：`mmap()`, `brk()`
    - 网络操作：`socket()`, `connect()`
#### 调用过程：
1. 系统发出interrupt中断，陷入指令（[[访管指令]]）trap后进入内核态（此时为用户态）
2. cpu通过系统调用号得知具体使用哪个中断服务程序，并通过[[中断#机制原理（响应过程）|硬件中断执行]] （传入时[[中断向量表IDT|IRQ]]为中断服务程序的指令号而非系统调用号），此时为软中断
3. 在结束中断后，cpu判定为内核态
4. cpu通过系统调用号找到对应的内核处理函数入口
5. 内核执行系统调用，内核可以直接访问硬件或内核数据结构（文件表、进程表、内存表等），内核执行完毕后，会将结果（返回值或错误码）放在寄存器里（比如 x86 的 `rax`）。
6. 内核通过 **返回中断/返回特权指令**（如 `iret`、`sysret`）将 CPU 状态切换回用户态，恢复用户程序的寄存器、程序计数器等现场信息，用户程序继续执行，拿到系统调用的返回值。
#### 系统调用类型：
![[Pasted image 20251210171812.png]]
#### 何时为特权何时为不特权？
- 系统调用的发起是**非特权**操作（此时为[[访管指令]]Trap），但系统调用内部执行的是**特权**操作
#### 库函数方便替换 → 调试更简单：
- 可以用自定义库函数替换标准库函数，插入调试信息或日志
- 例子：重写 `malloc` 或 `free`，统计内存分配情况，找内存泄漏
---
### 库函数（Library Function）
- **定义**：库函数是由开发者提供的一组函数，封装了一些常用功能，供程序直接调用。它们可能调用系统调用，也可能纯粹在用户态完成。
- **特点**：
    1. **位于用户态**：调用库函数一般不需要进入内核态（除非它内部调用了系统调用）。
    2. **便捷与高效**：提供了更高层次的抽象，减少程序员直接操作系统调用的复杂性。
    3. **实现可移植**：库函数可以屏蔽不同操作系统的底层差异，使程序更可移植。
- **例子**：
    - C 标准库：`printf()`, `scanf()`, `malloc()`, `free()`, `strcpy()`
    - POSIX 库函数：`fopen()`, `fread()`, `fwrite()`

#### 系统调用不方便替换 → 调试成本高：
- 系统调用是操作系统内核提供的，用户态代码直接替换困难
- 调试只能依赖操作系统提供的工具（如 `strace`、`gdb`）