### 产生原因
- 多个进程因竞争不可抢占性资源而造成的一种僵局
- 可消耗资源的竞争
- 进程的推进顺序不当：进程的异步性决定了在请求和释放资源时，如时机选择不当则可能出现死锁
### 必要条件：
1. 资源互斥：一段时间内某种资源只能被一个进程占用
2. 请求新资源与保持（不释放其已经得到的资源）的情况下进入阻塞态
3. 不可剥夺：进程资源在使用完前不可被抢占	
4. 循环等待：互相等待资源的进程环形链
### 死锁预防
#### 破坏“互斥”条件
- 缺点：临界资源本身特性决定其必须互斥访问
#### 破坏“请求和保持”条件
- 所有进程对资源的申请**在运行前一次性**进行
- 优点：简单，易于实现，安全
- 缺点：会造成资源浪费，使进程延迟进行，会导致cpu饥饿
#### 破坏“不剥夺”条件
- 进程逐个地提出对资源的请求，当一个进程提出的新资源请求不被满足时**释放**其已经保持的资源，从而破坏“不剥夺”条件
- 缺点：“被剥夺”可能会造成前段工作的失败，反复的申请/释放资源本身会造成系统开销
#### 破坏“环路等待”条件
- 将所有**资源**分成不同等级进行排序，并赋予不同的等级号，所有进程必须严格按照**资源号的递增**顺序提出请求，从而避免环路出现（任何等待链都是资源号**单调递增**的，不可能“绕回去”形成环）
- 缺点：限制了新类型设备的添加；会造成作业使用各类资源顺序和系统规定的顺序不一致的情况；会限制用户编程
### 死锁避免
#### 银行家算法
- 动态地为进程分配资源，但在资源分配之前计算此次资源分配地安全性
- 死锁 => 不安全
![[Pasted image 20260206214118.png]]
##### 算法思路
- 每次处理资源请求时，都要判断分配后剩余资源是否还能满足最大需求，并确保资源回收后仍能支持后续分配
##### 算法数据结构
1. 资源种类m，进程数n
2. 可利用资源向量Available
3. 最大需求矩阵Max
4. 分配矩阵Allocation
5. 需求矩阵Need
