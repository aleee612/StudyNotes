### 先来先服务调度算法（FCFS）
- 按照[[作业]]/进程进入就绪队列的先后顺序，先进入的先执行
- 是**非抢占**的调度算法
- **利长不利短**，短[[作业]]的带权周转时间很长
- 不会导致[[CPU饥饿]]
- ---
### 短[[作业]]优先调度算法（SJF）
- 选取**服务时间最短**的[[作业]]进行调度，使其立即执行并一直执行到完成或等待某事件而被阻塞后放弃处理机时在重新调度
- 一般默认为非抢占，不过抢占也有
- 在前置条件”同一时间内到达的进程中“，SJF的**效率最高**，其降低了[[作业]]的平均等待时间，提高了系统[[调度#调度原则#吞吐量|吞吐量]]
- 会有[[CPU饥饿]]情况：长[[作业]]（进程）的运行一直得不到保证
- ---
### 优先级调度算法（PSA）
- 分抢占式/非抢占式两种
	- 抢占式：优先级更高的进程一来，当前进程的处理机**立刻会被剥夺**，无论当前进程完成与否
	- 非抢占式：当前进程能运行到**完成**或出现等待事件而放弃处理机时**才分配**给高优先级的
- 优先级划分：静态优先级，动态优先级
	- 静态：优先级**出生即定**
	- 动态：会随时间推移调整（e.g：就绪队列中等待时间越长的进程优先级会变高，正在运行的进程[[cpu]]的处理时间越长优先级会变低）
- 优先级默认：
	- 系统进程>用户进程
	- 前台进程>后台进程
	- 操作系统更偏好I/O进程（比如I/O繁忙型进程）
- 会导致[[CPU饥饿]]，**低优先级的进程的调度没有保障**，但动态优先级会优化很多
- ---
### 最高响应比优先调度算法（HRRF）
- **响应比**=周转时间/服务时间 =1+等待时间/服务时间
- 该算法只考虑**[[作业]]等待时间**，忽视[[作业]]计算时间
- 引入响应比后使得[[作业]]**优先级随等待时间的增加而提高**（有点像PSA的改良版）
- 是**非抢占**式的算法
- 不会导致[[CPU饥饿]]（规避了）
- 性能在FCFS和SJF之间
- ---
### 时间片轮转调度算法（RR）
- 每次调度时，将处理机分配给队首进程，并令其执行一个**时间片**。时间片用完时，发出**[[中断]]**请求，停止该进程并将其放入**队尾**，而重新给队首分配处理机和时间片
- 该算法是**仅进程**的
- 是**抢占式**（时钟[[中断]]）
- 不会导致[[CPU饥饿]]
- 时间片的划分：
	- 过大时，变成FCFS了，效率降低
	- 过小时频繁发生[[中断]]，反而增加了系统开销
	- 所以一般时间片会略大于一次典型的交互所需的时间
---
### 多级反馈调度算法（MLFQ）
- 系统设置有多个就绪队列
- 不同队列分配不同大小的时间片，优先级高的队列时间片小
- 工作流程：假定就绪队列序号越小优先级越高
	1. 新进程进入内存 -> 放入队列 i
	2. 若一个时间片内未完成，则放入队列 i+1的队尾
	3. 当一个队列空闲时，调度进程才进入下一个队列中的程序运行
	4. 当有优先级高的新进程时，新进程将**抢占**正在运行的处理机，旧进程放入当前进程的队尾
- 由上可知这是抢占式的算法，以及会导致[[CPU饥饿]]
- ---
### 实时调度算法
- 适用于实时系统
#### 最早截止时间优先调度算法（EDF）
- 根据任务的**开始截止时间**来确定任务优先级，截止时间越早，优先级越高（ddl说是）
- 要求有实时任务就绪队列
- 分为非抢占式和抢占式，前者处理非周期性的实时任务，后者处理周期性的实时任务（调度延迟更低）
#### 最低松弛度优先调度算法（LLF）
- 根据任务紧急/松弛的程度来确定优先级，紧急程度越高，为该任务所赋予的优先级就越高
- 松弛度 = 截止时间 - 当前时间 - 剩余执行时间
- 主要为抢占式
- 理论上不会导致饥饿，但现实中会出现[[活锁]]
- ---
### 多处理器调度算法
- 主要考虑如何为进程分配处理器和如何选择调度算法
#### 1. 分配方式
1. **静态分配**：每个处理器对应一个就绪队列（1v1），利用率不高
2. **动态分配**：所有处理器对应同一个就绪队列（1vn），利用率有提高
#### 2. 多处理器调度算法
##### 1. 负载共享调度算法
- 进程不被指派到具体的处理器上，系统维护一个全局的就绪队列（动态分配）
- 必须保证互斥访问就绪队列
###### 1） 先来先服务调度算法（FCFS）
- 作用对象为线程
- 动态分配
- 线程本身运行时间短，每个进程的等待时间不会很长，因此开销小
###### 2）最小线程数优先调度算法
- 动态分配
- 来自具有最少的未被调度的线程数的[[作业]]的线程具有最高优先级
- 相同优先级的FCFS
- 通常一个线程能被一直运行到结束/阻塞
###### 3）抢占式最小线程数优先调度算法
- 当有高优先级的线程时允许抢占
- 其他与上面算法相同
#### 2.群调度算法
- 将一组线程同一时间一次性调度到一组处理机上运行（nvn）
- 减少了进程同步，切换等损失，提高性能
#### 3. 专用处理机调度算法
- 将一组处理机专门分配给一个应用程序（nvn）
- 可以看作群调度的一种极端方式
- 优点：避免进程的切换减慢程序的运行速度
- 缺点：
	- 浪费处理机
	- 线程切换可能很频繁（n v n+m）（线程越多，线程切换越频繁）
#### 4. 动态调度算法
- 动态的改变进程中的线程数
- 进程请求处理机时的调度：
	- 分配空闲的处理机以满足进程的请求
	- 若无则从当前分配了多个处理机的进程中回收一个
	- 若任何分配都无法满足，则保持未完成的状态
	- 每释放处理机时都要对还未解决过的请求处理机的进程队列进行扫描
- 算法开销比较大