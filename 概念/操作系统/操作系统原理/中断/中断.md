### 基本概念
- [[cpu]]停止处理正在运行的程序保留现场后去处理相应事件，结束后回到之前断点继续执行的过程
##### 特点
1. 随机性：可能随时出现
2. 可恢复性：完成中断后返回原点继续执行
3. 自动性：中断发生后的行为是os自动完成的
--- 
### 中断的作用
 1. 实现[[cpu]]与IO设备并行工作
 2. 实现硬件故障处理
 3. 实现人- 机通信
 4. 实现多道程序和分时操作
 5. 实现实时处理
 6. 实现应用程序和操作系统的联系
	 - 在用户程序中安排一条trap指令可进入操作系统，实现程序和操作系统的联系，称为软中断
 7. 实现[[多处理机系统]]中处理机之间的关系
	 - 在[[多处理机系统]]中，处理机和处理机之间的信息传递和任务切换也是通过中断实现
---
### 中断的类型
![[Pasted image 20251208085757.png]]
##### **外中断**（External / Hardware Interrupt）
- 源于 **外部设备**，比如键盘、鼠标、磁盘、网络等。
- 也叫 **硬件中断**。
##### **内中断**（Internal / Software Interrupt）
- 又称异常/同步中断
- 源于 **[[cpu]] 内部** 或 **软件指令**，比如非法操作、除零错误，或者系统调用
- 陷阱（trap）：陷入指令引发，应用程序故意引发
- 故障（falt）：错误条件引发
- 终止：致命错误
##### **硬件中断**（Hardware Interrupt）
- 触发方式：由硬件设备发起。
    - 例如：键盘按键、鼠标动作、网卡收到数据、定时器超时、硬盘读写完成。
- 特征：
    - 是 **外部事件**，CPU 被动响应。
    - 通常与外部设备的状态变化有关。
    - 可以异步发生，不依赖程序执行。
- 处理方式：
    - CPU 检测到中断请求信号（IRQ）后跳转到对应的中断处理程序。
- 判断方法：
    - 查看中断**向量表**，如果中断来源是 I/O 设备或定时器，一般是硬件中断。
    - 观察中断触发时是否有硬件事件发生。
##### **软件中断**（Software Interrupt）
- 触发方式：由 CPU 执行特定指令触发。
    - x86 指令：`INT n`（如 `INT 0x80` 用于 Linux 系统调用）
    - ARM 指令：`SVC`（Supervisor Call）
- 特征：
    - 是 **程序主动发起** 的。
    - 用于系统调用或操作系统服务。
- 处理方式：
    - CPU 执行指令后跳转到对应的系统调用处理程序。
- 判断方法：
    - 中断发生时，检查**触发指令**。如果是 `INT`、`SVC` 等，则是软件中断。
    - 通常软件中断发生在程序执行的特定位置，而非外部事件。
---
### 机制原理（响应过程）
#### CPU 进入“中断响应周期”
这一步是**硬件自动模式切换**，核心点：
- CPU 进入中断处理流程
- 停止取下一条普通指令
- 准备切换执行流
#### 自动保存现场（硬件完成）
CPU **不用问软件**，直接：
- 保存当前：
    - 程序计数器（PC / RIP）
    - 程序状态字（PSW / EFLAGS）
- 保存位置：
    - 栈（当前栈或内核栈，取决于架构）
	- 这是**中断能“返回”的根本原因**
#### 软硬件中断初期差异：
**软件：** 
1. 检测中断信号（发现中断源），信号传入向量号
2. cpu在收到中断信号时已得到中断向量号
**硬件：**
3. 外设[[拉 IRQ 线]] （IF判断在此时执行）
4. [[中断控制器]]收到请求
5. 中断控制器判优、编码，生成中断向量号
6. 中断控制器把这个向量号送给 CPU
#### 后期一致：
1. cpu查[[中断向量表IDT]] -> 找到需要执行的中断程序对应的地址
2. [[程序计数器PC]]指向cpu获得的地址
3. 由此 [[中断向量表IDT|ISR]] 第一条指令开始执行
