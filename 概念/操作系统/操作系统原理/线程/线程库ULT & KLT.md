> **Summary：**
> M:1快但阻塞影响全局，1:1并发和隔离好但成本高，M:N集大成者但实现复杂
### 常见能力：
- 创建 / 销毁线程
- 线程同步
    - 互斥锁（mutex）
    - 信号量（semaphore）
    - 条件变量
- 线程调度相关操作
    - 让出 CPU（yield）
    - 阻塞 / 唤醒
- 线程局部存储（TLS）
---
### 用户级线程库（User Library Thread）：使用 **M:1** 模型的线程库
**线程完全在用户态管理**
特点：
- 内核 **不知道** 这些线程的存在
- 调度由线程库自己完成
- M个用户态线程对应一个内核态线程
优点：
- 创建/切换快（不用进内核）
- 可移植性好
缺点（很要命）：
- **一个线程阻塞 = 全进程阻塞**
- 无法真正利用多核
典型例子：
- Java 早期 **Green Threads**
- 一些协程库（偏用户态调度）
适合：教学、实验、轻量并发  
不适合：真实高并发服务器

---
### 内核级线程库（Kernel Library Thread）：使用 **1:1** 模型的线程库
**线程由内核直接管理**
特点：
- 每个线程内核都认识
- 内核负责调度
- 一个用户态线程对应一个内核态线程
优点：
- 并发能力强（多核）
- 一个线程阻塞不影响其他线程
缺点：
- 创建 / 切换成本高（用户态 ↔ 内核态）
典型例子：
- **POSIX Threads（pthread）**
- Windows Threads
- Linux NPTL
现代操作系统的主流选择
---
### 混合线程库：使用 **M:N** 模型的线程库
**用户线程 ↔ 内核线程 映射**
思想：
- M 个用户线程映射到 N 个内核线程
- 用户态调度 + 内核态并行
优点：
- 比纯 ULT 强
- 比纯 KLT 省开销
缺点：
- 实现复杂
- 操作系统支持成本高
例子：
- Solaris 旧模型
- 一些语言运行时（思想类似）
理论很美，现实很累  
现在基本被 **1:1 模型** 干趴了