### 进程控制
> **进程控制 = 用原语安全地改变进程状态 + 管理资源**
- 原语特点：**原子性、不可中断**
- 原因：防止*状态改一半，被调度打断* 这种灾难现场
---
### 进程创建
#### 创建时机（记关键词就够）
- **作业投入**（批处理）
- **用户登录**
- **提供服务**（响应请求）
- **进程派生**（父进程创建子进程）
#### 创建步骤（4 步）
1. **申请 PCB**
2. **分配资源**（必要时告知父进程）
	- 内存：代码段 / 数据段 / 栈
	- CPU：不是马上跑，而是**获得被调度资格**
3. **初始化 PCB**
    - 标识符、父进程
    - 初始 CPU 状态
    - `PC → 程序入口`
    - 优先级、资源需求
    - 状态设为 **就绪态**
4. **插入就绪队列**
> 口诀：**要板子 → 给资源 → 写信息 → 排队跑**
---
### 进程终止
#### 终止原因（按“人为 / 程序 / 系统”记）
- **正常结束**
- **程序异常**
    - 超时、越界、算术错误
    - 无效 / 特权指令
    - I/O 错误
- **系统或外部干预**
    - 内存不足
    - 父进程请求 / 父进程终止 -> 为了防止孤儿进程乱跑
    - OS / 操作员干预
#### 终止原语步骤（核心 5 步）
1. **定位 PCB**
2. **若在运行 → 立即终止并触发重新调度**
3. **回收资源**
4. **终止子进程**
5. **释放 PCB**
> 核心思想：**先停、再还、后清干净**
---
### 进程阻塞
- 阻塞是主动行为，由进程自己发起
#### 阻塞原因
- 请求系统服务
- 等待 I/O 或某操作完成
- 等数据（协作进程）
- 暂无任务可执行
> **进程“暂时干不了活”，只能等**
#### 阻塞原语步骤（4 步）
1. **保存现场**
2. **状态 → 阻塞态**
3. **插入相应阻塞队列**
4. **调度其他进程**
---
### 进程唤醒
- 条件满足时，由 **OS 或相关进程** 执行
#### 唤醒原语
- 步骤：
	1. 从阻塞队列移出
	2. 状态 → 就绪态
	3. 插入就绪队列
- 注意：唤醒 ≠ 立即运行，还是要等调度。
