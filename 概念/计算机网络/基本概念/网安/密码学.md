- 明文：最初形式的报文 / 被解密后的报文
- 明文 + 加密算法 -> 密文
## 密钥
- 加密技术本身是已知的，而密钥（key）可以阻止解密
#### 加密方式
- 发送端提供Ka密钥，接收端提供Kb解密算法，明文m
- 则发送的密文为`Ka(m)`
- 接收进行`Kb(Ka(m)) = m` 进行解密
## 密钥系统
### 对称密钥系统：
- 发送 / 接收方密钥相同且保密
- 古老而简单的对称密码：[[凯撒密码]]
#### 块密码
- 要加密的报文被处理为k比特的块，每块独立加密，如图
![[Pasted image 20251012192912.png]]
- 一般k越大效果越好，但难以实现（发送方要将加密方式发给接收方）
- 所以用函数模拟随机排列表 ![[Pasted image 20251012193620.png]]
- 使用比特串作为密钥，它本身不做加密，只是进入算法的“密钥调度（key schedule）模块”中。然后这个模块**输出若干个中间密钥**（子密钥），这些子密钥再分别影响**特定“小型表”映射**（S-box 替换）和**算法内部的排列**（内部置换）
- 由于两个/更多个明文块加密后的部分内容（如HTTP发送报文首部）是相同的，因此可能造成已知明文攻击
- 思路：发送方为第i块明文块生成一个随机的k比特数r(i)，并计算$c(i) = Ks(m(i)\otimes r(i))$ ，由此即使m(i)m(j)相同，c(i)c(j)也不会相同，因为其r(i)不同
- 缺点：需要传输两倍内容（r(i)与m(i)等长）
#### 密码块连接CBC
- 改进：发送方在加密报文前生成一个随机的k比特串IV（初始向量），以明文的方式将IV发送给接收方（初始为c(0)）
- 对第一个块，计算$m(1)\otimes c(0)$，而后$c(1) = Ks(m(1)\otimes c(0))$ 
- 循环上一步
- 需要在协议中提供一种机制，以从发送方向接收方分发IV
###  公开密钥系统：
- 一个为全世界所知，一个仅由一方所知
- 解决了对称密钥无法确认对方是否为正确接收/发送方的问题
- 通信步骤：
	1. 接收方有两个密钥：已知的公钥与只有接收方知道的私钥
	2. 发送方先取得接收方的公钥，然后用这个公钥和一个周知的加密算法加密报文
	3. 接收方接收到密文，使用密钥和解密算法得到明文
#### 加密算法
##### RSA
- 广泛使用模n算数运算
