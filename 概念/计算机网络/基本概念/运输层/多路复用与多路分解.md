- 使用原因：进程有多个而网线只有一根（n : 1）
### 多路分解
- 将*运输层报文段* 中的数据 **交付** 到正确的*[[套接字]]* 的工作
- 在主机的每个[[套接字]]分配一个端口号，并将其指向相应的[[套接字]]
### 多路复用
- [[套接字]]中的数据块 + 首部信息（后用于分解） => 报文段 -> 传递到网络 
- 要求[[套接字]]有*唯一标识符* 
- 每个报文段有*特殊字段* 来指示该报文段所要交付到的[[套接字]]（首部信息中）
#### 特殊字段
- 源[[端口号]]字段
- 目的[[端口号]]字段
### 无连接的多路复用和多路分解（UDP）
- UDP[[套接字]]由一个二元组（目的IP，目的端口号）标识
- 即使源IP和源端口不相同，只要两个目的相同就会被定向到相同进程
#### 端口的分配
- 使用socket创建UDP[[套接字]]时，运输层从范围1024~65535内分配一个未被其他端口使用的端口号
```python
clientSocket = socket(AF_INET,SOCK_DGRAM)
```
- 也可自定义端口号
```python
clientSocket.bind('',19157)
```
- 如果实现的是一个周知协议的服务器端则要分配相应的周知端口号（0~1023）
#### 复用与分解步骤
源端口+目的端口+其他 => 运输层报文段 => 网络层IP数据报 => 接收端主机查目的端口号 => 交给对应[[套接字]]
### 面向连接的多路复用与多路分解
- TCP[[套接字]]由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识
- 两个不同源的报文段会被定向到两个不同的[[套接字]]，除非携带初始创建连接的请求
- TCP服务器进程有两套[[套接字]]，一套欢迎[[套接字]]（用于三次握手），一套连接[[套接字]]（用于报文传输）(编程只用写一个，详见[[TCP的连接需要两套套接字（欢迎与连接），为什么在套接字编程的时候只写一个？]])
### Web服务器与TCP
- 如今的高性能服务器通常只是用一个进程，但为每个新的客户连接创建一个新的[[套接字]]的新线程（由此可得连接[[套接字]]与进程之间并非一一对应）
- 使用持续HTTP的性能损耗比非持续的来得低