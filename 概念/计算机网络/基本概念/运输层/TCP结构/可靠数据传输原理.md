---
aliases:
  - rdt
---

- 实现在运输层
- 可靠数据传输协议的下一层可能是不可靠的，可将较低层直接视为不可靠的点对点信道
### 构造
#### rdt 1.0
- 最简单的情况：底层信道完全可靠
- 这个阶段其实rdt啥都没做，只是假设它为可靠而已
- 发送方/接收方都有一个[[有限状态机FSM]]用于定义自身状态
- 引起变迁的事件：
	- 发送方：`rdt_send(data)` -> 上层调用数据传输协议
	- 接收方：`rdt_rcv(packet)` -> 分组从信道到达
- FSM采取的行动：
	- 发送方：
		1. `packet = make_pkt(data)` -> 产生包含数据的分组
		2. `udt_send(packet)` -> （udt：_unreliable data transfer_（**不可靠的数据传输**））把数据包通过不可靠的信道发出去
	- 接收方：
		1. `extract(packet,data)` -> 从（不可靠信道）收到的分组中提取出数据部分
		2. `deliver_data()` -> 向较高层（应用层）交付数据
	- ⋀：表示缺少 动作/事件
- 有了完全可靠的信道，接收端不需要提供任何反馈信息给发送方
- 由于假定接受方的接收速率能和发送方一样快，所以没必要请求发送方慢点
#### rdt 2.0
- 假定所有发送的分组将按其发送的顺序被接收（虽然有些比特可能会受损）
- [[自动重传请求协议（ARQ）]]：使用 肯定（ACK）/否定（NAK） 确认，让接收方知道有 哪些内容被正确接收/哪些有误需重传
- 引起变迁的事件：
	- 发送方：
		1. `rdt_send(data)` -> 上层调用数据传输协议
		2. `rdt_rcv(rcvpkt) && isNAK(rcvpkt)` /  `rdt_rcv(rcvpkt) && isACK(rcvpkt)` -> 接收反馈信息，判断是否为NAK/ACK
	- 接收方：
		1.  `rdt_rcv(rcvpkt)` -> 分组从信道到达
		2. `corrupt(rcvpkt)`/ `notcorrupt(rcvpkt)`-> corrupt检查这个收到的包是否在传输过程中被损坏
- FSM采取的行动：
	- 发送方：
		1. `sndpkt = make_pkt(data,checksum)` -> 产生包含数据+校验和的分组
		2. `udt_send(packet)` -> 把数据包通过不可靠的信道发出去
		3. 当变迁事件为接收到NAK时，重新`udt_send(packet)`
		4. 当变迁事件为接收到ACK时，不做操作
	- 接收方：
		1. 当变迁事件为corrupt，则`sndpkt = make_pkt(NAK) && udt_send(packet)` -> 传输回NAK表示数据已损坏
		2. 当变迁事件为notcorrupt时，`extract(packet,data)` -> 从（不可靠信道）收到的分组中提取出数据部分
		3. 在 2 的基础上，用`deliver_data()` -> 向较高层（应用层）交付数据
		4. `sndpkt = make_pkt(ACK) && udt_send(packet)` -> 传输回ACK表示数据完整
- 注意事项：当发送方处于等待ACK/NAK状态时不能从上层获得更多数据，因此2.0也被称为**停等协议**
- 处理受损ACK/NAK：在数据分组中添加一新字段，让发送方对其数据分组编号，若接收数据正确则传输编号ACK（一般为0或1的1bit数据），若未接收到则不发NAK；当ACK为损坏时发送方将重发数据。这在2.1，2.2中实现
#### rdt 3.0
- 主要解决丢包问题
- 3.0也是一个停等协议
- 比特交替协议：分组序号在0和1之间交替
- 新定义了一个倒计数定时器，用于判断是否丢包，当超时未接收到ACK时，将重新发送分组
![[Pasted image 20251010164753.png]]