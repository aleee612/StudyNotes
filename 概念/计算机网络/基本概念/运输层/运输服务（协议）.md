---
aliases:
  - TCP
  - UDP
---
- 运输层提供的为不同主机**进程**之间的逻辑通信
## 概述
- 运输层协议之工作在端系统中，将来自应用进程的报文移动到网络边缘（网络层），而对其在网络中心如何移动不作规定
- 运输层协议常受制于底层网络层协议的服务模型
## 种类
1. 可靠数据传输
	- 使用原因：分组在计网中容易丢失，而部分数据丢失会导致严重后果
	- 提供了确保数据交付服务
2. 吞吐量
	- 发送进程能够向接收进程交付比特的**速率**
	- 随着该网络路径上的带宽上的会话的到达和离开而随着时间波动
	- 运输层协议：以某种特定的速率提供确保的可用吞吐量（r比特/秒）
	- 具有吞吐量要求的应用被称为**带宽敏感的应用**（多数为语音应用，云游戏之类对数据的时效性非常严格）
	- 一些**弹性应用**（例如下载操作）能够根据当时可用带宽或多或少的利用可供使用的吞吐量
3. 定时
	- 为了有效性而要求数据交付有严格的时间限制
4. 安全性
	- 加密由发送进程传输的所有数据

---
# 因特网提供的两种运输服务（协议）
- 基本责任：将两个端系统间**IP**的交付服务扩展为运行在端系统上的两个**进程**之间的交付服务（也被称为运输层的[[多路复用与多路分解]]）
![[Pasted image 20251009191603.png]]
## TCP服务
1. 面向链接服务
	- 在应用层数据报文开始流动之前，让c/s交换控制层信息（握手过程），由此建立TCP连接
	- 连接是[[全双工与半双工与单工#全双工|全双工]]的
	- 连接的双方都将初始化与TCP连接相关的许多TCP状态变量
2. [[可靠数据传输原理]]
	- 依靠TCP无差错、按适当顺序交付所有发送的数据
3. TCP连接是点到点（p2p）的，因此实现不了多播
4. 具有拥塞控制机制，限制每个TCP连接，使他们达到公平共享网络带宽的目的
5. 没有提供加密机制
6. 加强版：安全套接字层（SSL），提供了安全性服务（加密，数据完整性，端点鉴别），在发送主机中的SSL会加密数据并将加密的数据传递给TCP套接字，而由接收方的TCP套接字接收后将数据传递给SSL并解密
#### 发送缓存
- 在建立三次握手期间
- 可从缓存中取出并放入报文段中的数据数量受限于[[MSS最大报文长度|MSS]]（最大报文段长度）
- 本地发送缓存：数据 + TCP首部 -> TCP报文段 =>封在网络层IP数据报中 => 进入接收端接收缓存
#### TCP报文段结构
![[Pasted image 20251012135719.png]]
- 当TCP发送一个大文件时，通常是将文件分为长度是MSS的若干块
- 首部：
	- [[序号和确认号|32bit序号+32bit确认号]] => 实现[[可靠数据传输原理|可靠数据传输服务]]
	- 16bit接收窗口 => 用于流量控制（指示接收方愿意接收的字节数）
	- 4bit首部长度 => 首部长度 = 字段值 × 4 字节
	- 选项字段 => 协商MSS 、高速网络环境用作窗口调节因子
	- 6bit标志字段 （
		- ACK：确认字段中值有效；
		- RST，SYN，FIN：建立/删除连接；
		- CWR，ECE：明确拥塞报告；
		- PSH：置位时表示加受访应立即将数据交给上层；
		- URG：报文段中存在被发送端的上层实体置为“紧急”的数据 ）
- 最小首部 = 20B；最大首部：60B
#### 往返事件的估计与超时
1. 报文段样本[[往返时间（RTT）|RTT]]：SampleRTT
	- 测试范围：报文交给IP -> 报文段确认被收到
	- 仅为某个时刻做SampleRTT测量而非每个报文段都测
	- 绝不为重传的报文计算SampleRTT
2. SampleRTT平均值：EstimatedRTT
	- $EstimatedRTT = (1-α) · EstimatedRTT + α · SampleRTT$ 
	- α 的推荐值为 0.25
	- EstimatedRTT对最近的样本赋予的权值要大于对旧样本赋予的权值（指数加权移动平均EWMA）
3. RTT偏差：DevRTT
	- $DevRTT = (1+β)· DevRTT + β · | SampleRTT - EstimatedRTT |$
	- DevRTT是一个SampleRTT与EstimatedRTT之间插值的EWMA
	- SampleRTT波动小 -> DevRTT小
	- β 推荐值为 0.25
4. 设置和管理重传超时间隔
	- 超时间隔 >= EstimatedRTT
	- $TimeoutInterval = EstimatedRTT+4·DevRTT$
#### 如何实现可靠数据传输
- 推荐使用单一的重传定时器
**当发送端只用超时来恢复报文段的丢失：**
1. 通过RTT计算是否超时
2. 若超时则重传并重置定时器
3. 判断ACK与SendBase，通过累积确认确定字节编号y（ACK 的值）在y之前的所有字节都已经收到
4. 若y>SendBase，则表示ACK在确认一个或多个先前未被确认的报文段，发送方将更新其SendBase变量并重启定时器
- 每一个重传超时间隔都是前一个的两倍（对于同一段数据）
**当再加上冗余确认技术**
1. 发送方通过注意冗余ACK来检测丢包情况
2. 产生冗余ACK的原因：
![[Pasted image 20251014090316.png]]
3. TCP发送方一但接收到三个冗余ACK则执行快速重传
**选择确认**：[[流水线可靠数据传输协议（P-RDT）#回退N步GBN（滑动窗口协议）|GBN]]和[[流水线可靠数据传输协议（P-RDT）#选择重传SR|SR]]的混合体
- 允许TCP接收方有选择地确认失序报文段，而非累积地确认最后一个正确接收的有序报文段
- TCP最多重传一个报文段，因此不是传统意义上的GBN
- TCP使用累积确认，由此可见也并非传统SR
#### 流量控制
- 目的：发送方的发送速率和接收方应用程序的读取速率相匹配
- 发送方：维护接收窗口，指示接收方还有多少可用缓存空间（TCP是全双工所以双端都有）
- 当接收主机的接收窗口为0时，发送端继续发送只有一个字节数据的报文段以确保接收端后续会有新的空间
#### 三次握手
![[Pasted image 20251014094232.png]]
1. 客户端发送：SYN = 1，初始[[序号和确认号|序号]]：seq = client_isn
2. 连接在服务器被允许，服务器端为该TCP连接分配TCP缓存和变量，发送*SYNACK报文段*：SYN = 1，[[序号和确认号|确认号]]：ack = client_isn + 1，初始[[序号和确认号|序号]]：seq = server_isn
3. 在此时客户端才开始分配缓存和变量，发送：SYN：0，[[序号和确认号|序号]]：seq = client_isn + 1，[[序号和确认号|确认号]]：ack = server_isn
4. 由此三次握手结束，以后的每一个报文中SYN都为0
5. 认为在三次握手中RTT为1.5，但在步骤3时即可以开始传
#### 关闭连接
![[Pasted image 20251014095344.png]]
1. 客户发送关闭连接：FIN = 1
2. 服务器端发送确认ACK
3. 服务器端发送自己的终止报文段：FIN = 1
4. 客户端确认发送ACK
#### 拥塞控制
- 使用的为[[拥塞控制原理#端到端拥塞控制|端到端拥塞控制]]而非[[拥塞控制原理#网络辅助的拥塞控制|网络辅助拥塞控制]]，因为IP层不向系统提供显式的网络拥塞反馈
##### 如何检测拥塞
- 拥塞窗口cwnd：对一个TCP发送方能向网络发送流量的速率进行了限制
- 接收窗口rwnd
- 序号LBR，确认号LBA
- $LBR - LBA <= min| cwnd, rwnd|$ ：一个发送方中未被确认的数据量不会超过cwnd与rwnd中的最小值
- 自计时：TCP通过使用确认（ACK）来触发（或计时）增大它的拥塞窗口长度
##### 如何控制发送速率
- 一个丢失的报文段意味着拥塞，则当*丢失报文段时*应降低TCP发送方的速率
- 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此在*未确认报文段的确认到达时*，能够增加发送方的速率
- 带宽检测：用ACK指示无拥塞
##### 拥塞控制算法
![[Pasted image 20251015101240.png]]
1. 慢启动
	- 初始cwnd = 1[[MSS最大报文长度|MSS]] 
	- 初始 v = MSS / RTT
	- 每当传输的报文段首次被确认就cwnd += MSS，体现为翻倍 
	- 若是超时：ssthresh = cwnd/2，cwnd 重置为 1 MSS（回到慢启动）
	- 若是3 dup ACK（快速重传）：ssthresh = cwnd/2，cwnd = ssthresh + 3×MSS（进入快速恢复）
	- 当无丢包但有声明设置的拥塞控制初始阈值（也就是慢启动阈值ssthresh）时，当cwnd == ssthresh，则转换为只增加一个MSS
2. 拥塞避免
	- cwnd变为上次遇到拥塞时的一半
	- 此时RTT只将cwnd的值增加一个MSS（而非翻倍）
	- 当出现丢包 / 检测到拥塞 / 检测到三个冗余ACK 时停止增长，将cwnd减半，并将慢启动阈值（ssthresh）设为cwnd/2
3. 快速回复
	- 对收到的每个冗余的ACK，cwnd += MSS
	- 丢失报文的一个ACK到达 -> TCP在降低cwnd之后进入拥塞避免状态
	- 出现超时事件 -> 执行如同慢启动 / 拥塞避免中相同的动作 -> 迁移到慢启动状态
- 性质：加性增，乘性减（AIMD）

---
## UDP服务
1. 不提供不必要服务，轻量级，仅提供**最小服务**（即数据交付和差错检查）
2. 没有握手过程，无连接，提供的是不可靠数据传输服务，得到的数据可能乱序也可能根本就得不到数据
3. 没有拥塞控制机制，可以用它选定的任何速率向其下层（网络层）注入数据
#### 使用UDP的原因
1. 关于发送什么数据 & 何时发送的应用层控制更为精细：指能够不过分的延迟报文段的发送，且能容忍一些数据丢失
2. **无需连接建立**：不会引入建立连接的**时延**
3. 无连接状态：不用跟踪过多参数，能支持更多的活跃用户
4. 分组首部开销小：TCP 20字节首部，UDP 8字节
#### 常见的使用
1. [[DNS：目录服务|DNS服务]] -- 时延
2. 网络管理数据（SNMP）-- 无连接状态
#### UDP报文段结构
![[Pasted image 20251009191925.png]]
- 四个字段，每个字段两个字节，因此首部总共8字节
- 长度字段：首部 + 数据 的字节数。由于每个 UDP 段中数据部分的长度都可能不同，所以接收方必须知道这个段的总长度是多少。因此在 UDP 首部中必须包含一个明确的长度字段
- [[UDP校验和|校验和]]：检查该报文段中是否出现了差错（UDP报文段 + IP首部字段）
### 因特网不提供的服务：吞吐量与定时
