### 基本思想：
- 使用外部协助工具：**桶** 来实现数据的大小排序
- 在桶中另外使用冒泡，快排等排序方法进行排序
![[Pasted image 20260107220906.png]]
### 性质
- 平均时间复杂度：O ( n+k )，其中k为桶数
#### 什么题目适合使用桶排序？
1. 范围有限或者可以离散化，比如限定元素为范围0~100的小数
2. 元素分布比较均匀，这样效率高
3. 数据量大，内存足够分桶（也就是桶的数目不多）
### 实例
```cpp
#include <iostream>
#include <vector>
using namespace std;

void bucketSort(vector<int>& arr) {
    int n = arr.size();
    if (n <= 0) return;

    int maxValue = 100; // 假设数值范围 0~99
    int bucketCount = 10; // 桶的个数

    // 创建桶，每个桶是一个 vector
    vector<vector<int>> buckets(bucketCount);
    // 1️.分配到桶里
    for (int i = 0; i < n; ++i) {
        int index = arr[i] * bucketCount / maxValue; // 计算放哪个桶
        buckets[index].push_back(arr[i]);
    }
    // 2️.桶内排序（用简单的插入排序）
    for (int i = 0; i < bucketCount; ++i) {
        for (int j = 1; j < buckets[i].size(); ++j) {
            int key = buckets[i][j];
            int k = j - 1;
            while (k >= 0 && buckets[i][k] > key) {
                buckets[i][k + 1] = buckets[i][k];
                k--;
            }
            buckets[i][k + 1] = key;
        }
    }
    // 3️.合并所有桶
    int idx = 0;
    for (int i = 0; i < bucketCount; ++i) {
        for (int val : buckets[i]) {
            arr[idx++] = val;
        }
    }
}

int main() {
    vector<int> arr = {78, 17, 39, 26, 72, 94, 21, 12, 23, 68};

    bucketSort(arr);

    for (int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}

```
### 题目汇总
- [U322215 【模板】桶排序 - 洛谷](https://www.luogu.com.cn/problem/U322215)  
- [P1271 【深基9.例1】选举学生会 - 洛谷](https://www.luogu.com.cn/problem/P1271) 