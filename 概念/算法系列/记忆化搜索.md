# vector模板

```
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo;

int dfs(int n) {
    if (n == 0) return 0;  // 基本情况
    if (memo[n] != -1) return memo[n];  // 如果已经计算过，直接返回结果

    // 计算子问题的结果
    int result = n + dfs(n - 1);  // 假设这里是一个递归过程

    // 将结果保存到 memo 中
    memo[n] = result;

    return result;
}

int main() {
    int n;
    cin >> n;

    // 初始化 memo 数组，-1 表示未计算过
    memo.resize(n + 1, -1);

    cout << dfs(n) << endl;
    return 0;
}
```

# map模板（哈希）

```
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// 存储子问题的结果
unordered_map<string, int> memo;  // 用哈希表存储中间结果，也可以使用 vector 或其他容器

// 记忆化递归函数
int dfs(int n, int m) {
    // 构造当前子问题的唯一标识
    string key = to_string(n) + "," + to_string(m);
    
    // 如果已经计算过这个子问题，直接返回结果
    if (memo.count(key)) {
        return memo[key];
    }

    // 递归的出口，处理基本情况
    if (n == 0 || m == 0) {
        return 0; // 基本情况
    }

    // 计算当前子问题的结果
    int result = max(dfs(n - 1, m), dfs(n, m - 1));  // 假设做一个递归的选择

    // 存储计算结果，以便以后使用
    memo[key] = result;

    return result;
}

int main() {
    int n, m;
    cin >> n >> m;
    
    cout << dfs(n, m) << endl;
    
    return 0;
}
```

- 记忆化搜索在bfs，dfs非常常用