p2563背包

## 由递归到一维

```c++
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

// 递归版本
int fib1(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fib1(n - 1) + fib1(n - 2);
}

// 记忆化递归版本
int fib2(int n) {
    vector<int> dp(n + 1, -1);
    return fib2Helper(n, dp);
}

int fib2Helper(int n, vector<int>& dp) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (dp[n] != -1) return dp[n];
    dp[n] = fib2Helper(n - 1, dp) + fib2Helper(n - 2, dp);
    return dp[n];
}

// 动态规划版本
int fib3(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

// 空间优化版本
int fib4(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    int lastLast = 0, last = 1;
    for (int i = 2; i <= n; i++) {
        int cur = lastLast + last;
        lastLast = last;
        last = cur;
    }
    return last;
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;

    cout << "fib1: " << fib1(n) << endl;
    cout << "fib2: " << fib2(n) << endl;
    cout << "fib3: " << fib3(n) << endl;
    cout << "fib4: " << fib4(n) << endl;

    return 0;
}
```

## 二维

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// 暴力递归
int f1(const vector<vector<int>>& grid, int i, int j) {
    if (i == 0 && j == 0) return grid[0][0];

    int up = INT_MAX, left = INT_MAX;
    if (i - 1 >= 0) up = f1(grid, i - 1, j);
    if (j - 1 >= 0) left = f1(grid, i, j - 1);

    return grid[i][j] + min(up, left);
}

int minPathSum1(const vector<vector<int>>& grid) {
    return f1(grid, grid.size() - 1, grid[0].size() - 1);
}

// [[记忆化搜索]]
int f2(const vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp) {
    if (dp[i][j] != -1) return dp[i][j];

    int ans;
    if (i == 0 && j == 0) {
        ans = grid[0][0];
    } else {
        int up = INT_MAX, left = INT_MAX;
        if (i - 1 >= 0) up = f2(grid, i - 1, j, dp);
        if (j - 1 >= 0) left = f2(grid, i, j - 1, dp);
        ans = grid[i][j] + min(up, left);
    }
    dp[i][j] = ans;
    return ans;
}

int minPathSum2(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, -1));
    return f2(grid, n - 1, m - 1, dp);
}

// 动态规划
int minPathSum3(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, 0));
    dp[0][0] = grid[0][0];
    for (int i = 1; i < n; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j < m; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];

    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[n - 1][m - 1];
}

// 动态规划 + 空间压缩
int minPathSum4(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    vector<int> dp(m, 0);
    dp[0] = grid[0][0];
    for (int j = 1; j < m; j++) {
        dp[j] = dp[j - 1] + grid[0][j];
    }

    for (int i = 1; i < n; i++) {
        dp[0] += grid[i][0];
        for (int j = 1; j < m; j++) {
            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }

    return dp[m - 1];
}

int main() {
    vector<vector<int>> grid = {
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1}
    };

    cout << "暴力递归结果: " << minPathSum1(grid) << endl;
    cout << "记忆化搜索结果: " << minPathSum2(grid) << endl;
    cout << "动态规划结果: " << minPathSum3(grid) << endl;
    cout << "动态规划 + 空间压缩结果: " << minPathSum4(grid) << endl;

    return 0;
}
```

## 三维

```c++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// 暴力递归
int f1(const vector<vector<int>>& grid, int i, int j) {
    if (i == 0 && j == 0) return grid[0][0];
    int up = INT_MAX, left = INT_MAX;
    if (i - 1 >= 0) up = f1(grid, i - 1, j);
    if (j - 1 >= 0) left = f1(grid, i, j - 1);
    return grid[i][j] + min(up, left);
}

int minPathSum1(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    return f1(grid, n - 1, m - 1);
}

// [[记忆化搜索]]
int f2(const vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp) {
    if (dp[i][j] != -1) return dp[i][j];
    int ans;
    if (i == 0 && j == 0) {
        ans = grid[0][0];
    } else {
        int up = INT_MAX, left = INT_MAX;
        if (i - 1 >= 0) up = f2(grid, i - 1, j, dp);
        if (j - 1 >= 0) left = f2(grid, i, j - 1, dp);
        ans = grid[i][j] + min(up, left);
    }
    dp[i][j] = ans;
    return ans;
}

int minPathSum2(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, -1));
    return f2(grid, n - 1, m - 1, dp);
}

// 严格位置依赖的动态规划
int minPathSum3(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, 0));
    dp[0][0] = grid[0][0];
    for (int i = 1; i < n; ++i)
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j < m; ++j)
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    for (int i = 1; i < n; ++i)
        for (int j = 1; j < m; ++j)
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    return dp[n - 1][m - 1];
}

// 空间压缩动态规划
int minPathSum4(const vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    vector<int> dp(m);
    dp[0] = grid[0][0];
    for (int j = 1; j < m; ++j)
        dp[j] = dp[j - 1] + grid[0][j];
    for (int i = 1; i < n; ++i) {
        dp[0] += grid[i][0];
        for (int j = 1; j < m; ++j)
            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
    }
    return dp[m - 1];
}

int main() {
    vector<vector<int>> grid = {
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1}
    };

    cout << "minPathSum1 (暴力递归): " << minPathSum1(grid) << endl;
    cout << "minPathSum2 (记忆化搜索): " << minPathSum2(grid) << endl;
    cout << "minPathSum3 (二维DP): " << minPathSum3(grid) << endl;
    cout << "minPathSum4 (一维DP): " << minPathSum4(grid) << endl;

    return 0;
}
```