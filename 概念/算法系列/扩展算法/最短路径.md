Dijkstra

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <climits>
using namespace std;

const int MAXN = 100001;
const int MAXM = 200001;

int head[MAXN], nxt[MAXM], to[MAXM], weight[MAXM];
int cnt;

int heap[MAXN];        // 堆结构
int where[MAXN];       // 反向索引
int heapSize;
int distance[MAXN];

int n, m, s;

void build() {
    cnt = 1;
    heapSize = 0;
    memset(head, 0, sizeof(head));
    memset(where, -1, sizeof(where));
    for (int i = 1; i <= n; i++) distance[i] = INT_MAX;
}

void addEdge(int u, int v, int w) {
    nxt[cnt] = head[u];
    to[cnt] = v;
    weight[cnt] = w;
    head[u] = cnt++;
}

void swap(int i, int j) {
    int tmp = heap[i];
    heap[i] = heap[j];
    heap[j] = tmp;
    where[heap[i]] = i;
    where[heap[j]] = j;
}

void heapInsert(int i) {
    while (distance[heap[i]] < distance[heap[(i - 1) / 2]]) {
        swap(i, (i - 1) / 2);
        i = (i - 1) / 2;
    }
}

void heapify(int i) {
    int l = i * 2 + 1;
    while (l < heapSize) {
        int best = l + 1 < heapSize && distance[heap[l + 1]] < distance[heap[l]] ? l + 1 : l;
        best = distance[heap[best]] < distance[heap[i]] ? best : i;
        if (best == i) break;
        swap(i, best);
        i = best;
        l = i * 2 + 1;
    }
}

bool isEmpty() {
    return heapSize == 0;
}

int pop() {
    int ans = heap[0];
    swap(0, --heapSize);
    heapify(0);
    where[ans] = -2;
    return ans;
}

void addOrUpdateOrIgnore(int v, int w) {
    if (where[v] == -1) {
        heap[heapSize] = v;
        where[v] = heapSize++;
        distance[v] = w;
        heapInsert(where[v]);
    } else if (where[v] >= 0) {
        if (w < distance[v]) {
            distance[v] = w;
            heapInsert(where[v]);
        }
    }
}

void dijkstra() {
    addOrUpdateOrIgnore(s, 0);
    while (!isEmpty()) {
        int v = pop();
        for (int ei = head[v]; ei; ei = nxt[ei]) {
            int u = to[ei], w = weight[ei];
            addOrUpdateOrIgnore(u, distance[v] + w);
        }
    }
}

int main() {
    scanf("%d %d %d", &n, &m, &s);
    build();
    for (int i = 0; i < m; i++) {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        addEdge(u, v, w);
    }
    dijkstra();
    for (int i = 1; i <= n; i++) {
        printf("%d%c", distance[i], i == n ? '\n' : ' ');
    }
    return 0;
}
```