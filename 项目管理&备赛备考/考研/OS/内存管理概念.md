### 内存分配过程
#### 适应算法
##### 分配算法
![[Pasted image 20260208190646.png]]

| 算法                      | 优点                          | 缺点                               | 速度  |
| ----------------------- | --------------------------- | -------------------------------- | --- |
| **First Fit** <br>首次适应  | • 查找速度快<br>• 综合表现稳定         | • 低地址区域容易产生碎片                    | 快   |
| **Next Fit** <br>循环首次适应 | • 分配更均匀<br>• 避免低地址集中碎片      | • 可能需要循环查找<br>• 利用率略低于 First Fit | 较快  |
| **Best Fit** <br>最佳适应   | • 单次分配浪费最少<br>• 局部空间利用率最高   | • 需要遍历查找<br>• 长期容易产生大量小碎片        | 慢   |
| **Worst Fit** <br>最坏适应  | • 初期能保留较多中等空闲块<br>• 小碎片相对较少 | • 容易破坏大块连续空间<br>• 总体利用率较低        | 慢   |
##### 利用率计算
	利用率 = 申请的内存大小 / 空闲块大小
##### 内存回收过程
本质：合并相邻内存块
#### 伙伴算法
##### 分配
![[Pasted image 20260208191849.png]]
- 如图的方式将内存分块，当需要分配内存时，算法寻找合适的块；如果没有合适的块，就将更大的块一分为二，直到满足需求
- 释放内存时，算法尝试将相邻的“伙伴”块（相同大小地址相邻的块）合并为更大的块，以减少 **内存碎片**。
### 离散分配管理方式
#### 页式管理 & 段式管理 & 段页式管理

|对比项|页式管理 Paging|段式管理 Segmentation|段页式管理 Segmented Paging|
|---|---|---|---|
|核心思想|固定大小分页|按程序逻辑分段|先分段，再分页|
|划分依据|物理划分|逻辑划分|逻辑 + 物理结合|
|大小是否固定|页固定|段不固定|页固定，段不固定|
|地址结构|页号 + 页内偏移|段号 + 段内偏移|段号 + 页号 + 页内偏移|
|是否体现程序逻辑|❌ 不体现|✅ 强体现|✅ 体现|
|内存碎片|内部碎片|外部碎片|只有少量内部碎片|
|内存利用率|高|较低|高|
|管理复杂度|简单|中等|复杂|
|硬件实现难度|低|中|高|
|共享与保护|一般|很好|很好|
|是否常用于现代OS|✅ 是|❌ 少单独用|✅ 是（理论结构，思想被用）|
### 错题
> 在下列动态分区分配算法中，最容易产生内存碎片的是（ ）。
	A.首次适应算法      B.最坏适应算法      C.最佳适应算法      D.循环首次适应算法
- **最容易产生大量小外部碎片**
	-> 最佳适应 Best Fit
- **最容易造成大块内存被破坏 / 浪费**
	-> 最坏适应 Worst Fit