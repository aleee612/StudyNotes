### 临界区和互斥
- 讲究环境：并发
- 
**临界区**：
- 指一个程序中仅允许 **一个线程** 或 **进程** 访问的**代码片段**。
- 这些代码通常会访问 **共享资源**，比如内存、文件、数据库等。
- 当多个线程或进程试图同时访问这些共享资源时，可能会导致数据不一致或其他并发问题。
**互斥**：
- 作用：保证在 **一个时刻只有一个线程或进程** 能够访问 **临界区** 的代码。
- 主要目标：避免资源竞争和数据不一致的问题
- 意义：确保数据的完整性
### 临界资源
- 就是 **共享资源**，可以被多个 **线程/进程** 同时访问。  
- 如全局变量
### 互斥
| 方法   | 说明                                     |
| ---- | -------------------------------------- |
| 软件互斥 | 依赖算法和程序设计来确保 **临界资源** 的独占              |
| 硬件互斥 | 使用 CPU 指令集中的 **原子指令** 来实现 **临界资源** 的独占 |
| 锁    | 操作系统提供的 API，软件直接调用即可实现资源独占             |
| 信号量  | 操作系统提供的 API，可以用 **信号量** 来实现锁的功能        |
#### 互斥锁
- 提供方：操作系统
- 本质： **同步原语**
- 作用：实现多线程对于 **临界资源** 的 **互斥**
- 具体实施：
	- 任何时候，只有 **一个线程** 可以持有 **互斥锁**。其它试图获取该锁的 **线程** 将被 **阻塞**，直到持有锁的线程 **释放** 该锁。
	- 只有锁的持有者才能释放它。这确保了非持有者不能误释放锁。
- 操作：**加锁** 和 **解锁**
- 等待锁的进程为阻塞态，唤醒后转变为就绪态
#### 软件互斥
##### Peterson 算法
- 基于 **两个线程** 之间的竞争条件来实现互斥
- 它使用 **两个布尔变量** 和 **一个整数变量**，分别表示两个线程的意愿和当前正在运行的线程。
- 通过这些变量的协作，可以确保只有一个线程能够进入临界区。
```cpp
#include <iostream>
#include <thread>
#include <mutex>

// 共享资源
int counter = 0;

// 创建互斥量
std::mutex mtx;

// 线程1的工作
void thread1() {
    for (int i = 0; i < 5; ++i) {
        // 进入临界区，互斥访问共享资源
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
        std::cout << "Thread 1: counter = " << counter << std::endl;
    }
}

// 线程2的工作
void thread2() {
    for (int i = 0; i < 5; ++i) {
        // 进入临界区，互斥访问共享资源
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
        std::cout << "Thread 2: counter = " << counter << std::endl;
    }
}

int main() {
    // 创建两个线程
    std::thread t1(thread1);
    std::thread t2(thread2);

    // 等待线程执行完毕
    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter << std::endl;

    return 0;
}
```
#### 硬件互斥
##### 原子性
- 指一个操作是不可分割的，要么完全执行，要么完全不执行
- 在多线程或多进程环境中，**原子性**确保操作不会被其他并发操作中断
**原子指令**：
被设计为在单个处理器指令周期内执行完毕，不会被中断或其他线程干扰
##### TAS 指令
- 原子性地设置一个内存位置的值为 1，并返回该位置的先前值。
```c
// TAS 原子指令相当于以下函数被原子性地执行
int test_and_set(bool *lock) {
    bool old = *lock;  // 读旧值
    *lock = true;      // 把锁设为“已上锁”
    return old;        // 返回旧值
}
```
- 不管原来锁是什么状态，我都先把它锁上，然后告诉你“锁之前是不是已经被别人锁了”
**自旋锁**：
- 用一个整数变量表示，0 表示锁是空闲的，1 表示锁已经被占用。  
- **加锁** 操作：不断使用 **TAS** 指令来尝试将锁的值从 0 设置为 1，如果返回的先前值为 0，则表示 **锁定成功**，否则表示 **锁定失败**
- **解锁** 操作将锁的值设置为 0
工作原理：
- 当一个 **线程** 执行 **TAS** 指令时，它会读取一个共享变量 **mutex** 的值。
- 如果该值为 0（或 false），则 **线程** 将该值设置为 1（或 true），并继续执行 **临界区** 代码。
- 如果该值为 1（或 true），则 **线程** 将无法获取锁，需要等待锁被释放。
- 当 **线程** 完成 **临界区** 代码的执行后，它会将共享变量的值重置为 0（或 false），以 **释放锁**。
##### CAS 指令
- 原子性地比较内存中的一个值与预期值，如果相等，则将内存中的值替换为新值
```c
// CAS 原子指令相当于以下函数被原子性地执行
bool compare_and_swap(bool *lock, bool expected, bool new_value) {
    if (*lock == expected) {
        *lock = new_value;
        return true;  // 操作成功
    } else {
        return false; // 操作失败
    }
}
```
与TAS的区别：
- **只有条件满足才写内存**
- 总线流量小，性能更好
- 能搞 **无锁数据结构**
- 有 ABA 问题
- 逻辑比 TAS 复杂
> **ABA 问题**：
> 	CAS 只检查“值是不是原来的 A”，  
> 	但**不知道这个 A 中途有没有被改成 B 又改回来**。
### 同步
范围：
- 包括 **互斥** 控制
- **线程** 之间的顺序协调、条件等待、信号传递等机制
原则：
- **空闲让进**
- **忙则等待**
- **有限等待**：每个等待进入临界区的线程都有机会在有限时间内进入，避免 “死等”；
- **让权等待**：不能进入临界区的线程应主动放弃 CPU（如进入等待队列），避免 “忙等”

- **死等** 状态：指一个 **线程/进程** 长期得不到资源或 **临界区** 的访问权，即使条件已经满足，也可能因为调度策略、优先级问题或实现缺陷，永远无法被唤醒或执行
- **忙等** 状态：指 **线程/进程** 未能进入 **临界区**，但却反复占用 CPU 执行检查操作，不断轮询某个变量或状态，以判断自己是否可以进入 **临界区** 