### BCD码
- 每个十进制数字（0-9）都使用 **四位二进制数字** 表示
- 如：19 -> 0001 1001
### 二进制表示
- 正数表示：n位01，首位为0，范围 $2^{n-1}-1$  
- 负数表示：首位为 1，**补码** 表示，范围 $-2^{n-1}$  
#### 原码 -> 反码 -> 补码
- 正数都不变
- 负数：反码为原码按位取反（首位不变），补码为反码+1
#### 已知二进制算十进制：补码 -> 反码 -> 原码
- 负：反码为补码-1，原码为反码按位取反（首位不变）
#### 移位
| 数值类型 | 移位类型    | 移位规则    | 高位/低位补 | 结果特点   | 溢出/精度                 |
| ---- | ------- | ------- | ------ | ------ | --------------------- |
| 正数   | 算术左移 << | × $2^n$ | 低位补 0  | 正数继续变大 | 可能溢出（超范围）             |
| 正数   | 算术右移 >> | ÷ $2^n$ | 高位补 0  | 正数变小   | 不溢出，可能丢精度（奇数向下取整）     |
| 负数   | 算术左移 << | × $2^n$ | 低位补 0  | 负数变小   | 可能溢出（符号位翻转）           |
| 负数   | 算术右移 >> | ÷ $2^n$ | 高位补 1  | 负数接近 0 | 不溢出，可能丢精度（奇数向 0 取整）   |
| 任意数  | 逻辑右移 >> | /$2^n$  | 高位补 0  | 会变正    | 有符号数用逻辑右移会改变符号（通常不允许） |
- 也就是只有负数算术右移会高位补1
- 乘左除右
#### 基本数据类型计算位数：
| 类型          | 字节数 (Bytes) | 位数 (Bits) | 有符号范围            | 无符号范围      |
| ----------- | ----------- | --------- | ---------------- | ---------- |
| `char`      | 1           | 8         | -128 ~ 127       | 0 ~ 255    |
| `short`     | 2           | 16        | -32,768 ~ 32,767 | 0 ~ 65,535 |
| `int`       | 4           | 32        | -2³¹ ~ 2³¹-1     | 0 ~ 2³²-1  |
| `long`      | 4 或 8       | 32 或 64   | 系统相关             | 系统相关       |
| `long long` | 8           | 64        | -2⁶³ ~ 2⁶³-1     | 0 ~ 2⁶⁴-1  |
| `float`     | 4           | 32        | IEEE 754 单精度     | —          |
| `double`    | 8           | 64        | IEEE 754 双精度     | —          |
> [!warning] 做题须知
 **溢出：**
 指运算的结果超过当前位数能表示的范围，
 或在移位中高位被挤出导致符号位翻转
 **标志：** CF 看“位”，OF 看“符号”
 OF
 即是否溢出标志，0为未溢出，1为溢出
 表示有符号数运算结果
 CF
 同上，表示无符号数运算结果
 >
 **精度丢失：**
 在左移的过程中，运算结果虽然在寄存器范围内，但低位信息被舍弃
 如 7 / 2 => 3 就是因为末位的 1 被舍弃
 >
>> 为什么题目要用 FEH、F2H 这种方式表示？
 ->  因为这是“8 位寄存器里的真实比特模式”
 这种如何计算？
 -> 视为一个字母/数字对应四位二进制即可

### 错题
> 某字长为 8 位的计算机中，已知整型变量 x、y 的机器数分别为 x 补=1111 0100 ， y 补=1011 0000 。若整型变量 z=2x+y/2，则 z 的机器数为（ ）。
	A.11000000      B.00100100      C.10101010      D.溢出
- x的反码为1111 0011，则原码为1000 1100，十进制数为-12
- y的反码为1010 1111，则原码为1101 0000，十进制数为-80
- 说明此时的相加不会引起溢出
- `2*x`说明是算数左移，移动后为1110 1000；`y/2`说明是算数右移，补1，移动后为1101 1000
- 说明无精度丢失
- 相加后为 1100 0000

> 考虑以下 C 语言代码：
```c
unsigned short usi = 65535;
short si = usi;
```
> 执行上述程序段后，si 的值是（ ）。
	A.-1     B.-32767     C.-32768     D.-65535
- 考察溢出，有符号达不到65535
- 65535 即 $2^{16}-1$ ，1111 1111 1111 1111 的代表意思为-1