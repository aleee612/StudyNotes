---
aliases:
  - 最优二叉树
---

![[Pasted image 20251030170734.png]]
哈夫曼树是什么？
**哈夫曼树（Huffman Tree）** 又叫 **最优二叉树（Optimal Binary Tree）**，  
是一种带**权值（weight）**的二叉树，它能让**带权路径长度最短**。
> 简单说：在所有可能的二叉树中，**哈夫曼树能让“经常出现的东西”路径更短，整体更高效。**
---
## 几个关键词你得知道
- **权值（weight）**：某个节点的重要性或出现频率，比如字符出现次数。
- **路径长度（path length）**：从根节点到某个节点走的边数。
- **带权路径长度（WPL）**：所有叶子节点的权值 × 路径长度 的和。
哈夫曼树的目标就是让这个 **WPL 最小化**。
---
## 构造步骤（核心算法）
哈夫曼树的构造非常简单又巧妙：
> 1️⃣ 把每个权值都看作一个独立的节点  
> 2️⃣ 选出两个权值最小的节点，合并为一个新节点，**新节点的权值 = 两者之和**  
> 3️⃣ 把新节点放回集合中，重复 2️⃣  
> 4️⃣ 最后只剩一个根节点，那就是哈夫曼树！
---
## 举个例子
假设我们有权值：
```
A: 5
B: 9
C: 12
D: 13
E: 16
F: 45
```
### 构造过程：

| 步骤  | 选最小两个 | 合并后新节点 | 集合中的权值         |
| :-- | :---- | :----- | :------------- |
| 1   | 5, 9  | 14     | 12,13,14,16,45 |
| 2   | 12,13 | 25     | 14,16,25,45    |
| 3   | 14,16 | 30     | 25,30,45       |
| 4   | 25,30 | 55     | 45,55          |
| 5   | 45,55 | 100    | ✅ 完成（根节点）      |

这样就得到了哈夫曼树。  
权值小的节点（比如A、B）离根更远，权值大的（比如F）离根更近。

---
## 哈夫曼编码（超实用！）
哈夫曼树常用于**数据压缩**，比如文件压缩、JPEG、MP3等。
比如上面的树中，从根到各叶子节点路径可以定义 0 和 1：

|字符|编码|
|:--|:--|
|F|0|
|C|101|
|D|100|
|A|1100|
|B|1101|
|E|111|

出现频率高的（F）编码更短，出现少的（A、B、E）编码更长。  
这样平均每个字符的比特数就减少了，实现压缩。

---
## 哈夫曼树的特点总结
✅ 不唯一（只要满足最小WPL，有多种形态）  
✅ 没有度为1的节点（每个非叶子节点都有两个孩子）  
✅ 常用于**哈夫曼编码、文件压缩、信息传输**

---
## 一句话总结
> **哈夫曼树 = 权值越大，离根越近；整体路径长度最小的二叉树。**

---

要不要我给你画一个上面那个例子的哈夫曼树图？📊  
一眼看就懂整个“压缩逻辑”是怎么来的～