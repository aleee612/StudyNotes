# 动态数组vector

```cpp
#include<vector>
//头文件

#include<iostream>
using namespace std;

int main(){
    vector<int> v1;             // 空vector
    vector<vector<int>>v;       // 二维vector  
    vector<int> v2(5);          // 5个默认初始化的元素（int默认值是0）
    vector<int> v3(5, 10);      // 5个元素，初始值都为10
    vector<vector<int>> v3(5, vector<int>(4,10)); // 5*4个元素，初始值都为0
    vector<int> v4 = {1, 2, 3}; // 列表初始化
    vector<int> v5(v4);         // 拷贝构造
    
    
    // 尾插
    v.push_back(4); 
        // 删除最后一个
        v.pop_back();
        // 指定位置插入
        v.insert(v.begin() + 1, 10); 
        // 指定位置删除
        v.erase(v.begin() + 1);
        // 清空所有元素
        v.clear();
        
        cout << v[0] << endl;
        cout << v.at(1) << endl; // 带越界检查
        cout << v.front() << endl; // 获取第一个元素
        cout << *v.begin() << endl;
        cout << v.back() << endl; // 获取最后一个元素
        cout << *(v.end()-1) << endl;
        cout << v[i] << endl; // 支持下标索引
        
        vector<int> v = {1, 2, 3};

        //普通for循环
        for (int i = 0; i < v.size(); i++) {
            cout << v[i] << " ";
        }
        //迭代器遍历
        for (auto it = v.begin(); it != v.end(); it++) {
            cout << *it << " ";
        }
        //C++11范围for循环
        for (int x : v) {
            cout << x << " ";
        }
        
        cout << v.size() << endl;      // 获取元素个数
        cout << v.capacity() << endl;  // 获取容量
        cout << v.empty() << endl;     // 判断是否为空

        v.resize(5, 100);  // 重新调整大小，新增的填充100
        
        return 0；
}
```

# list链表

# 队列 | 优先队列(堆)

队列没有迭代器，只能访问队首和队尾

```c++
#include <iostream>
#include <queue> 
// 包含 queue 和 priority_queue

using namespace std;

int main() {
    // 普通队列（queue）—— fifo
    queue<int> q;

    q.push(10);    // 入队
    cout <<  q.front() <<  q.back() << endl;    // 访问队首和队尾
    q.pop();    // 出队

    // 优先队列（priority_queue）—— 最大堆，默认大元素优先
    priority_queue<int> pq;
    pq.push(30);

    while (!pq.empty()) {
        cout << pq.top() << " "; // 访问堆顶
        pq.pop(); // 移除堆顶
    }

    // 最小堆（priority_queue）—— 使用 greater 变为小元素优先
    priority_queue<int, vector<int>, greater<int>> minPq;
    minPq.push(30);
    while (!minPq.empty()) {
        cout << minPq.top() << " ";
        minPq.pop();
    }

    return 0;
}
```

# 栈stack

p4387

栈没有迭代器，只能访问栈顶

```c++
#include <iostream>
#include <stack>

using namespace std;

int main() {
    stack<int> s;

    // 入栈 (push)
    s.push(10);

    // 访问栈顶元素 (top)
    cout << s.top() << endl;

    // 出栈 (pop)
    s.pop();

    // 栈是否为空 (empty)
    cout << (s.empty() ? "是" : "否") << endl;

    // 获取栈的大小 (size)
    cout << s.size() << endl;

    // 遍历栈（LIFO 顺序）
    while (!s.empty()) {
        cout << s.top() << " ";
        s.pop();
    }

    return 0;
}
```

# 二元组pair

```c++
#include <iostream>
#include <utility>//pair头文件
#include <algorithm>
#include <map>

using namespace std;

int main() {

    pair<int, string> p1(1, "Alice");
    pair<int, double> p2 = make_pair(2, 3.14);
    pair<string, string> p3{"Hello", "World"};

    cout << p1.first << p1.second << endl;
    cout << p2.first << p2.second << endl;
    cout << p3.first << p3.second << endl;

    // 交换
    pair<int, int> a = {10, 20}, b = {30, 40};
    swap(a, b);
    cout <<  a.first << a.second << b.first << b.second << endl;

    // 用 pair 作为 map 的键值对
    map<string, int> mp;
    mp.insert(make_pair("apple", 5));//make_pair()返回一个pair类型的值

    // 用 pair 存储排序数据
    vector<pair<int, string>> v = {{3, "C"}, {1, "A"}, {2, "B"}};
    sort(v.begin(), v.end()); // 按 first 排序

    return 0;
}
```

# 映射map

p3613

```c++
#include <iostream>
#include <map>
using namespace std;

int main() {
    // 前键后值
    map<string, int> mp;

    mp["apple"] = 5;  // 索引
    mp.insert({"banana", 3});
    mp.emplace("cherry", 7);
    
    cout << mp["apple"] << endl;

    // 遍历（使用迭代器）
    for (auto it = mp.begin(); it != mp.end(); ++it) {
        cout << it->first << " -> " << it->second << endl;
    }
    for (const auto& p : mp) {
        cout << p.first << " -> " << p.second << endl;
    }

    // 查找
    if (mp.find("cherry") != mp.end()) {
        cout  << mp["cherry"] << endl;
    }

    // 删除
    mp.erase("banana");
    for (const auto& p : mp) {
        cout << p.first << " -> " << p.second << endl;
    }

    // map大小
    cout <<  mp.size() << endl;

    return 0;
}
```

# 字符串string

```c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main() {

    string s1 = "Hello";
    string s2("World");
    string s3 = s1 + " " + s2; // 拼接

    cout << s3.length() << endl;
    cout << s3.size() << endl;
    cout << s3.front() <<  s3.back() << endl;
    cout << *s3.begin() << *(s3.end()-1) << endl;

        for (int i = 0;i<s3.length();i++){
                cout << s3[i] << " ";
        }
    for (char c : s3) {
        cout << c << " ";
    }
        
        //hello world
    size_t pos = s3.find("World");//返回起始索引
    if (pos != string::npos) {
        s3.replace(pos, 5, "C++");
    }//起始位置，替换的字符数，用于替换的字符串
   

    // 插入和删除
    s3.insert(5, " Beautiful");
    s3.erase(5, 10);

    // 字符串转换
    int num = 123;
    string strNum = to_string(num);
    
    string str = "456";
    int n = stoi(str);
    cout << n << endl;

    // 反转字符串
    reverse(s3.begin(), s3.end());
    cout << "反转后: " << s3 << endl;

    return 0;
}
```

# 集合set

```c++
#include <iostream>
#include <set>
#include <unordered_set>

using namespace std;

int main() {
    // 有序集合（set）—— 基于红黑树，自动排序
    set<int> orderedSet = {4, 2, 8, 1, 5};

    orderedSet.insert(3);    // 插入
    orderedSet.erase(2);    // 删除
    if (orderedSet.find(5) != orderedSet.end()) {    // 查找元素
        cout << "5 存在于 set 中" << endl;
    }
    
    // 遍历 set（有序）
    for (int num : orderedSet) {
        cout << num << " ";
    }

    // 无序集合（unordered_set）—— 基于哈希表，插入和查找更快
    unordered_set<int> unorderedSet = {4, 2, 8, 1, 5};

    unorderedSet.insert(3);    // 插入
    unorderedSet.erase(2);    // 删除
    if (unorderedSet.count(5)) {    // 查找元素
        cout << "5 存在于 unordered_set 中" << endl;
    }

    // 遍历 unordered_set（无序）
    for (int num : unorderedSet) {
        cout << num << " ";
    }

    return 0;
}
```