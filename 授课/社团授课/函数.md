# 基本结构

和c语言一样，我们cpp中的函数也包含了形式参数，实际参数，函数调用，返回值几个部分，这里就不过多赘述了

```
#include<iostream>
using namespace std;
int add(int a,int b)
{
    return a+b;
}
int main()
{
    cout << add(1,2);
    return 0;
}
```

# 重载

那么什么是重载呢？我们又应该在什么时候使用重载呢？

#### a. 什么是重载？

**同名**函数，可以根据参数个数或类型不同来实现不同功能。

#### b. 示例代码：

```
#include<iostream>
using namespace std;
void greet() {
    cout << "你好！" << endl;
}

void greet(string name) {
    cout << "你好，" << name << "！" << endl;
}
int main()
{
    greet();
    greet("aleee");
    return 0;
}
```

#### c. 什么时候用重载？

- **功能相似，处理数据类型不同**

比如：打印、排序、加法、比较 等函数，经常重载

```
void add(int a, int b);
void add(double a, double b);
```

**目的：让函数接口更统一，调用方便，不用记不同的函数名。**

- **函数功能一致，但参数个数不同**

```
void log(string message);
void log(string message, int level);
void log(string message, int level, string module);
```

#### d. 注意：

- ✅ 参数不同 → 可以重载
- ❌ 只改返回值 → 不行！

#### e. 练习题：

习题：小宠物的“说话”时间（Say Something！）

**题目背景：**

你正在开发一个“桌宠”，桌宠可以“说话”。不同的输入让它说不同的话。

请你写一个重载的 `say()` 函数，让它具备以下功能：

**函数需求：**

1. `void say()`  
    没有参数时，输出：

```
（小宠物眨了眨眼，似乎什么也没说。）
```

2. `void say(string message)`  
    传入一段文本，输出：

```
小宠物说：“[message]”
```

3. `void say(int times)`  
    传入次数，重复输出：

```
喵！
喵！
喵！（共 times 次）
```

4. （加分挑战）`void say(string message, int emotionLevel)`  
    根据 `emotionLevel` 不同，输出不同语气：

- 0：冷漠地说
- 1：正常说
- 2：兴奋地说（加表情）

**比如：**

```
小宠物冷漠地说：“hello.”
小宠物说：“hello~”
小宠物兴奋地说：“hello!! (≧▽≦)”
```

**要求：**

- 所有函数名都必须是 `say`
- 写一个 `main()` 函数，演示你自己设计的所有用法

---

# 参数的传递-`&`的使用

## 一、参数传递基础

### 1. 普通值传递

```
void addOne(int x) {
    x = x + 1;
}

int main() {
    int a = 5;
    addOne(a);
    cout << a << endl;  // 输出 5，不变
}
```
`x` 是 `a` 的拷贝，函数内的修改不会影响外部。
### 2. 指针传递
```
void addOne(int* x) {
    *x = *x + 1;
}

int main() {
    int a = 5;
    addOne(&a);  // 传入 a 的地址
    cout << a << endl;  // 输出 6
}
```
### 3. 引用传递
```
void addOne(int& x) {
    x = x + 1;
}

int main() {
    int a = 5;
    addOne(a);
    cout << a << endl;  // 输出 6，值变了！
}
```

- `int& x` 表示 `x` 是 `a` 的**别名（引用）**
- 函数内部对 `x` 的修改，会直接影响外部变量 `a`

### 4. 如何引用数组？

```
void printArray(int (&arr)[5]) {
    for (int i = 0; i < 5; ++i)
        cout << arr[i] << " ";
}
```

- ❌ `int &arr`

- `int&` 是引用一个单独的 int
- 编译器会说：“你这是拿一个 `int&` 去接一个 `int[5]`，类型不匹配啊！”

- ❌ `int &arr[5]`

- 它表示的其实是一个长度为 5 的**int** 引用的数组（也就是说它其实是数组）

### 5. 容器呢？

```
void printVector(const vector<int>& vec) {
    for (int v : vec)
        cout << v << " ";
}
```

---

### 小练习：

```
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
```

```
void swapArrays(int (&a)[N], int (&b)[N]) {
    for (int i = 0; i < N; ++i) {
        int temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
```

---

# 递归初入门

函数调用自己就是递归

```
int factorial(int n) {
    if (n == 1) return 1;     // 基础情况
    return n * factorial(n - 1);  // 递归调用
}
```

### 递归的两个关键要素：

1. **基准情况**：什么时候停？
2. **递归调用**：让问题越来越小

---

### 示例一：阶乘 n!

```
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

### 示例二：斐波那契数列 F(n) = F(n-1) + F(n-2)

```
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**提示：**

- 递归容易爆栈，要控制好终止条件！

无限循环和无限递归在报错上的区别

- 无限循环**不会立刻报错**，但程序会**卡死**、**无法结束**，[[cpu]]会持续占用。 （很快你电脑风扇就起来了……）
- 无限递归**会崩溃并报错，** 通常是：`Segmentation fault`（段错误） 或 `stack overflow`（栈溢出） （ 系统直接终止 ）

- 斐波那契递归效率低，后续可以学习“[[动态规划]]”优化

---

# 例题与练习

![](https://cdn.nlark.com/yuque/0/2025/png/55421216/1746771468904-a88ebe45-a703-4bed-bb63-0d73563aff98.png)

```
#include<iostream>
#include<math.h>

using namespace std;

double sum(double x1, double x2, double y1, double y2 ) {
	double k =abs((x1 - y1) * (x1 - y1) + (x2 - y2) * (x2 - y2));
	return k;
}



int main() {

	double x1, x2, y1, y2, z1, z2;
	cin >> x1 >> x2;
	cin >> y1 >> y2;
	cin >> z1 >> z2;

	double s =sqrt(sum(x1, x2, y1, y2)) + sqrt(sum(x1, x2, z1, z2)) + sqrt(sum(z1, z2, y1, y2)) ;
	printf("%.2lf\n", s);


	return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/55421216/1746771629662-6ac7617e-7039-4907-8af0-7c3d6244ef19.png)

```
#include<algorithm>
#include<iostream>
#define LL long long
using namespace std;
long long ans = 1;
int n;
void jie_cheng(int x)
{
	ans *= x;
	if(x == n)
	{
		return;
	}
	jie_cheng(x + 1);
}
int main()
{
	scanf("%d", &n);
	jie_cheng(1);
	printf("%lld\n", ans);
	return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/55421216/1746771664879-1812eedc-3bab-47c9-9938-5dad2d56c5b7.png)

```
#include <iostream>
using namespace std;

void reversePrint() {
    int x;
    cin >> x;
    if (x == 0) return;     // 读到 0 直接结束
    reversePrint();         // 递归读下一个数
    cout << x << " ";       // 回溯时输出
}

int main() {
    reversePrint();
    return 0;
}
```